[toc]

### 4.7 创建新View

#### 4.7.1 修改存在的View





### 11.7 增强你的View

判断`Canvas`是否支持硬件加速：
```java
canvas.isHardwareAccelerated()
```

#### 11.7.1 高级 Canvas 绘图

本节介绍的多数技术都是关于`Paint`的变化，实现深度和纹理。

Android的绘制API支持变透明、渐变填充、圆角矩形、反锯齿。

Android不支持矢量绘制，支持传统的光栅（raster）图。

##### 可以绘制什么？

`Canvas`有一组`draw*`方法：
- `drawARGB`/`drawRGB`/`drawColor`：用单色填充画布
- `drawArc`：Draws an arc between two angles within an area bounded by a rectangle.
- `drawBitmap`：在画布上绘bitmap。You can alter the appearance of the target bitmap by specifying a target size or using a matrix to transform it.
- `drawBitmapMesh`：Draws a bitmap using a mesh that lets you manipulate the appearance of the target by moving points within it.
- `drawCircle`：Draws a circle of a specified radius centered on a given point.
- `drawLine(s)`：Draws a line (or series of lines) between two points.
- `drawOval`：Draws an oval bounded by the rectangle specified.
- `drawPaint`：Fills the entire Canvas with the specified Paint.
- `drawPath`：Draws the specified Path. A `Path` object is often used to hold a collection of drawing primitives within a single object.
- `drawPicture`：Draws a `Picture` object within the specified rectangle (not supported when using hardware acceleration.)
- `drawPosText`：Draws a text string specifying the offset of each character (not supported when using hardware acceleration).
- `drawRect`：绘制矩形
- `drawRoundRect`：Draws a rectangle with rounded edges.
- `drawText`：Draws a text string on the Canvas. The text font, size, color, and rendering properties are set in the `Paint` object used to render the text.
- `drawTextOnPath`：Draws text that follows along a specified path (not supported when using hardware acceleration).
- `drawVertices`：Draws a series of tri-patches specified as a series of vertex points (not supported when using hardware acceleration).

##### `Paint`

通过`Pain`，可以控制颜色、样式、字体和特效。

> Not all the `Paint` options described here are available if you’re using hardware acceleration to improve 2D drawing performance. As a result, it’s important to check how hardware acceleration affects your 2D drawing.

`setColor`设置的Paint的颜色。
`setStyle`设置`Paint`的样式，to decide if you want to draw only the outline of a drawing object (`STROKE`), just the filled portion (`FILL`), or both (STROKE_AND_FILL).

`Paint`类还支持透明，可以被 Shaders, filters, and effects 修饰。

The Android SDK includes several excellent projects that demonstrate most of the features available in the `Paint` class. They are available in the graphics subfolder of the API demos at:

	[sdk root folder]\samples\android-15\ApiDemos\src\com\example\android\apis\graphics

###### 半透明

创建颜色：
```java
// Make color red and 50% transparent
int opacity = 127;
int intColor = Color.argb(opacity, 255, 0, 0);
int parsedColor = Color.parseColor(“#7FFF0000”);
```

设置`Paint`的透明度：
``` java
// Make color 50% transparent
int opacity = 127;
myPaint.setAlpha(opacity);
```

You can use transparency effects in any class or method that uses colors including Paint colors, Shaders, and Mask Filters.

###### Shaders

Extensions of the `Shader` class let you create Paints that fill drawn objects with more than a single solid color.

Shaders的最常见的用法是渐变填充，渐变是向 2D 添加深度和纹理的好方式。Android包含三个渐变Shaders，及一个Bitmap Shader和一个Compose Shader。

Trying to describe painting techniques seems inherently futile, so Figure 11-7 shows how each Shader works. Represented from left to right are `LinearGradient`, `RadialGradient`, and `SweepGradient`.

![](gradient3.png)

###### Gradient Shaders

两种定义渐变的方式。第一种是两色渐变：
```java
int colorFrom = Color.BLACK;
int colorTo = Color.WHITE;
LinearGradient myLinearGradient =
	new LinearGradient(x1, y1, x2, y2, colorFrom, colorTo, TileMode.CLAMP);
```

第二种，指定督工额渐变色：
```java
int[] gradientColors = new int[3];
gradientColors[0] = Color.GREEN;
gradientColors[1] = Color.YELLOW;
gradientColors[2] = Color.RED;

float[] gradientPositions = new float[3];
gradientPositions[0] = 0.0f;
gradientPositions[1] = 0.5f;
gradientPositions[2] = 1.0f;

RadialGradient radialGradientShader
	= new RadialGradient(centerX, centerY, radius,
		gradientColors, gradientPositions,
		TileMode.CLAMP);
```

设置使用何种Shader：
```java
shaderPaint.setShader(myLinearGradient);
```

Anything you draw with this Paint will be filled with the Shader you specified rather than the paint color.

###### Shader Tile Modes

The brush sizes of the gradient Shaders are defined using explicit bounding rectangles or center points and radius lengths; the Bitmap Shader implies a brush size through its bitmap size.

如果Shader brush定义的区域小于要填充的区域，`TileMode`定义剩余区域如何被填充。可用值：
- CLAMP：使用Shader边缘色填充额外空间
- MIRROR：水平/垂直反转Shader图像，让图片看上去能连起来
- REPEAT：重复，但不反转

###### Mask Filters

The `MaskFilter` classes let you assign **edge effects** to your Paint. **Mask Filters are not supported when the Canvas is hardware-accelerated.**

Extensions to MaskFilter apply transformations to the alpha-channel of a Paint along its outer edge. Android includes the following Mask Filters:
- BlurMaskFilter — Specifies a blur style and radius to feather the edges of your Paint
- EmbossMaskFilter — Specifies the direction of the light source and ambient light level to add an embossing effect(浮雕特效)

To apply a Mask Filter, use the `setMaskFilter` method, passing in a `MaskFilter` object:
```java
// Set the direction of the light source
float[] direction = new float[]{ 1, 1, 1 };
// Set the ambient light level
float light = 0.4f;
// Choose a level of specularity to apply
float specular = 6;
// Apply a level of blur to apply to the mask
float blur = 3.5f;
EmbossMaskFilter emboss = new EmbossMaskFilter(direction, light, specular, blur);
// Apply the mask
if (canvas.isHardwareAccelerated())
	myPaint.setMaskFilter(emboss);
```

The FingerPaintAPI demo included in the SDK is an excellent example of how to use `MaskFilters`. It demonstrates the effect of both the emboss and blur filters.

###### Color Filters

Whereas **Mask Filters are transformations of a Paint’s alpha-channel**, a `ColorFilter` applies a transformation to each of the RGB channels. All ColorFilter-derived classes ignore the alpha channel when performing their transformations.

Android includes three Color Filters:
- `ColorMatrixColorFilter`：Lets you specify a 4 x 5 ColorMatrixto apply to a Paint. Color Matrixes are commonly used to perform image processing programmatically and are useful because they support chaining transformations using matrix multiplication.
- `LightingColorFilter` — Multiplies the RGB channels by the first color before adding the second. The result of each transformation will be clamped between 0 and 255.
- `PorterDuffColorFilter` — Lets you use any one of the 16 Porter-Duff rules for digital image compositing to apply a specified color to the Paint. The Porter-Duff rules are defined here at http://developer.android.com/reference/android/graphics/PorterDuff.Mode.html.

Apply ColorFilters using the `setColorFilter` method:
```java
myPaint.setColorFilter(new LightingColorFilter(Color.BLUE, Color.RED));
```

An excellent example of using a Color Filter and Color Matrixes is in the ColorMatrixSampleAPI example:
samples\android-15\ApiDemos\src\com\example\android\apis\graphics\ColorMatrixSample.java

###### Path Effects

The effects described so far affect the way the Paint **fills** a drawing; Path Effects are used to control how its outline (or stroke) is drawn.

Path Effects are particularly useful for drawing Path primitives, but they can be applied to any Paint to affect the way the stroke is drawn.

Using Path Effects, you can change the appearance of a shape’s corners and control the appearance of the outline. Android includes several Path Effects, including the following:
- `CornerPathEffect`：Lets you smooth sharp corners in the shape of a primitive by replacing them with rounded corners.
- `DashPathEffect`：Rather than drawing a solid outline, you can use the DashPathEffect to create an outline of broken lines (dashes/dots). You can specify any repeating pattern of solid/empty line segments.
- `DiscretePathEffect` — Similar to the DashPathEffect, but with added randomness. Specifies the length of each segment and a degree of deviation from the original path to use when drawing it.
- `PathDashPathEffect` — Enables you to define a new shape (path) to use as a stamp to outline the original path.

The following effects let you combine multiple Path Effects to a single Paint:
- `SumPathEffect` — Adds two effects to a path in sequence, such that each effect is applied to the original path and the two results are combined.
- `ComposePathEffect` — Applies first one effect and then applies the second effect to the result of the first.

Path Effects that modify the shape of the object being drawn change the area of the affected shape. This ensures that any fill effects applied to the same shape are drawn within the new bounds.

Path Effects are applied to Paintobjects using the `setPathEffect` method:
```java
borderPaint.setPathEffect(new CornerPathEffect(5));
```

The Path Effects API sample gives an excellent guide to how to apply each of these effects:

	samples\android-15\ApiDemos\src\com\example\android\apis\graphics\PathEffects.java

###### Changing the Transfer Mode

Change a Paint’s `Xfermode` to affect the way it paints new colors on top of what’s already on the Canvas. Under normal circumstances, painting on top of an existing drawing layers the new shape on top. If the new Paint is fully opaque, it totally obscures the paint underneath; if it’s partially transparent, it tints the colors underneath.

The following `Xfermode` subclasses let you change this behavior:
- `AvoidXfermode` — Specifies a color and tolerance to force your Paint to avoid drawing over (or only draw over) it.
- `PixelXorXfermode` — Applies a simple pixel XOR operation when covering existing colors.
- `PorterDuffXfermode` — This is a very powerful transfer mode with which you can use any of the 16 Porter-Duff rules for image composition to control how the paint interacts with the existing canvas image.

To apply transfer modes, use the `setXferMode` method:
```java
AvoidXfermode avoid = new AvoidXfermode(Color.BLUE, 10, AvoidXfermode.Mode.AVOID);
borderPen.setXfermode(avoid);
```

##### 利用反锯齿提高绘制质量

When you create a new `Paint` object, you can pass in several flags that affect the way the Paint will be rendered. One of the most interesting is the `ANTI_ALIAS_FLAG`, which ensures that diagonal lines drawn with this paint are anti-aliased to give a smooth appearance (at the cost of performance).

Anti-aliasing is particularly important when drawing text, as anti-aliased text can be significantly easier to read. To create even smoother text effects, you can apply the `SUBPIXEL_TEXT_FLAG`, which applies subpixel anti-aliasing.
```java
Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG|Paint.SUBPIXEL_TEXT_FLAG);
```

You can also set both of these flags manually using the `setSubpixelText` and `setAntiAlias` methods:
```java
myPaint.setSubpixelText(true);
myPaint.setAntiAlias(true);
```

##### Canvas 绘制最佳实践






