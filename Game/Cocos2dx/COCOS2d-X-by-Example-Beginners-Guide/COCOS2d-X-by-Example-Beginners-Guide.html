<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>COCOS2d-X-by-Example-Beginners-Guide.html</title>
  <meta name="generator" content="Haroopad 0.11.1" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>div.oembedall-githubrepos{border:1px solid #DDD;border-radius:4px;list-style-type:none;margin:0 0 10px;padding:8px 10px 0;font:13.34px/1.4 helvetica,arial,freesans,clean,sans-serif;width:452px;background-color:#fff}div.oembedall-githubrepos .oembedall-body{background:-moz-linear-gradient(center top,#FAFAFA,#EFEFEF) repeat scroll 0 0 transparent;background:-webkit-gradient(linear,left top,left bottom,from(#FAFAFA),to(#EFEFEF));border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-top:1px solid #EEE;margin-left:-10px;margin-top:8px;padding:5px 10px;width:100%}div.oembedall-githubrepos h3{font-size:14px;margin:0;padding-left:18px;white-space:nowrap}div.oembedall-githubrepos p.oembedall-description{color:#444;font-size:12px;margin:0 0 3px}div.oembedall-githubrepos p.oembedall-updated-at{color:#888;font-size:11px;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats{border:medium none;float:right;font-size:11px;font-weight:700;padding-left:15px;position:relative;z-index:5;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats li{border:medium none;color:#666;display:inline-block;list-style-type:none;margin:0!important}div.oembedall-githubrepos ul.oembedall-repo-stats li a{background-color:transparent;border:medium none;color:#666!important;background-position:5px -2px;background-repeat:no-repeat;border-left:1px solid #DDD;display:inline-block;height:21px;line-height:21px;padding:0 5px 0 23px}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a{border-left:medium none;margin-right:-3px}div.oembedall-githubrepos ul.oembedall-repo-stats li a:hover{background:none no-repeat scroll 5px -27px #4183C4;color:#FFF!important;text-decoration:none}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a:hover{border-bottom-left-radius:3px;border-top-left-radius:3px}ul.oembedall-repo-stats li:last-child a:hover{border-bottom-right-radius:3px;border-top-right-radius:3px}span.oembedall-closehide{background-color:#aaa;border-radius:2px;cursor:pointer;margin-right:3px}div.oembedall-container{margin-top:5px;text-align:left}.oembedall-ljuser{font-weight:700}.oembedall-ljuser img{vertical-align:bottom;border:0;padding-right:1px}.oembedall-stoqembed{border-bottom:1px dotted #999;float:left;overflow:hidden;width:730px;line-height:1;background:none repeat scroll 0 0 #FFF;color:#000;font-family:Arial,Liberation Sans,DejaVu Sans,sans-serif;font-size:80%;text-align:left;margin:0;padding:0}.oembedall-stoqembed a{color:#07C;text-decoration:none;margin:0;padding:0}.oembedall-stoqembed a:hover{text-decoration:underline}.oembedall-stoqembed a:visited{color:#4A6B82}.oembedall-stoqembed h3{font-family:Trebuchet MS,Liberation Sans,DejaVu Sans,sans-serif;font-size:130%;font-weight:700;margin:0;padding:0}.oembedall-stoqembed .oembedall-reputation-score{color:#444;font-size:120%;font-weight:700;margin-right:2px}.oembedall-stoqembed .oembedall-user-info{height:35px;width:185px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-gravatar32{float:left;height:32px;width:32px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-details{float:left;margin-left:5px;overflow:hidden;white-space:nowrap;width:145px}.oembedall-stoqembed .oembedall-question-hyperlink{font-weight:700}.oembedall-stoqembed .oembedall-stats{background:none repeat scroll 0 0 #EEE;margin:0 0 0 7px;padding:4px 7px 6px;width:58px}.oembedall-stoqembed .oembedall-statscontainer{float:left;margin-right:8px;width:86px}.oembedall-stoqembed .oembedall-votes{color:#555;padding:0 0 7px;text-align:center}.oembedall-stoqembed .oembedall-vote-count-post{font-size:240%;color:#808185;display:block;font-weight:700}.oembedall-stoqembed .oembedall-views{color:#999;padding-top:4px;text-align:center}.oembedall-stoqembed .oembedall-status{margin-top:-3px;padding:4px 0;text-align:center;background:none repeat scroll 0 0 #75845C;color:#FFF}.oembedall-stoqembed .oembedall-status strong{color:#FFF;display:block;font-size:140%}.oembedall-stoqembed .oembedall-summary{float:left;width:635px}.oembedall-stoqembed .oembedall-excerpt{line-height:1.2;margin:0;padding:0 0 5px}.oembedall-stoqembed .oembedall-tags{float:left;line-height:18px}.oembedall-stoqembed .oembedall-tags a:hover{text-decoration:none}.oembedall-stoqembed .oembedall-post-tag{background-color:#E0EAF1;border-bottom:1px solid #3E6D8E;border-right:1px solid #7F9FB6;color:#3E6D8E;font-size:90%;line-height:2.4;margin:2px 2px 2px 0;padding:3px 4px;text-decoration:none;white-space:nowrap}.oembedall-stoqembed .oembedall-post-tag:hover{background-color:#3E6D8E;border-bottom:1px solid #37607D;border-right:1px solid #37607D;color:#E0EAF1}.oembedall-stoqembed .oembedall-fr{float:right}.oembedall-stoqembed .oembedall-statsarrow{background-image:url(http://cdn.sstatic.net/stackoverflow/img/sprites.png?v=3);background-repeat:no-repeat;overflow:hidden;background-position:0 -435px;float:right;height:13px;margin-top:12px;width:7px}.oembedall-facebook1{border:#1A3C6C solid 1px;padding:0;font:13.34px/1.4 verdana;width:500px}.oembedall-facebook2{background-color:#627add}.oembedall-facebook2 a{color:#e8e8e8;text-decoration:none}.oembedall-facebookBody{background-color:#fff;vertical-align:top;padding:5px}.oembedall-facebookBody .contents{display:inline-block;width:100%}.oembedall-facebookBody div img{float:left;margin-right:5px}div.oembedall-lanyard{-webkit-box-shadow:none;-webkit-transition-delay:0s;-webkit-transition-duration:.4000000059604645s;-webkit-transition-property:width;-webkit-transition-timing-function:cubic-bezier(0.42,0,.58,1);background-attachment:scroll;background-clip:border-box;background-color:transparent;background-image:none;background-origin:padding-box;border-bottom-width:0;border-left-width:0;border-right-width:0;border-top-width:0;box-shadow:none;color:#112644;display:block;float:left;font-family:'Trebuchet MS',Trebuchet,sans-serif;font-size:16px;height:253px;line-height:19px;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;max-width:none;min-height:0;outline-color:#112644;outline-style:none;outline-width:0;overflow-x:visible;overflow-y:visible;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;position:relative;text-align:left;vertical-align:baseline;width:804px}div.oembedall-lanyard .tagline{font-size:1.5em}div.oembedall-lanyard .wrapper{overflow:hidden;clear:both}div.oembedall-lanyard .split{float:left;display:inline}div.oembedall-lanyard .prominent-place .flag:active,div.oembedall-lanyard .prominent-place .flag:focus,div.oembedall-lanyard .prominent-place .flag:hover,div.oembedall-lanyard .prominent-place .flag:link,div.oembedall-lanyard .prominent-place .flag:visited{float:left;display:block;width:48px;height:48px;position:relative;top:-5px;margin-right:10px}div.oembedall-lanyard .place-context{font-size:.889em}div.oembedall-lanyard .prominent-place .sub-place{display:block}div.oembedall-lanyard .prominent-place{font-size:1.125em;line-height:1.1em;font-weight:400}div.oembedall-lanyard .main-date{color:#8CB4E0;font-weight:700;line-height:1.1}div.oembedall-lanyard .first{width:48.57%;margin:0 0 0 2.857%}html{height:100%}body{margin:0!important;padding:5px 20px 26px!important;background-color:#fff;font-family:"Lucida Grande","Segoe UI","Apple SD Gothic Neo","Malgun Gothic","Lucida Sans Unicode",Helvetica,Arial,sans-serif;font-size:.9em;overflow-x:hidden;overflow-y:auto}br,h1,h2,h3,h4,h5,h6{clear:both}hr.page{background:transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;border:0 none;color:#ccc;height:3px;padding:0}hr.underscore{border:0 none!important;height:30px;padding:0;-webkit-margin-before:0;-webkit-margin-after:0}body >:first-child{margin-top:0!important}img.plugin{box-shadow:0 1px 3px rgba(0,0,0,.1);border-radius:3px}iframe{border:0}figure{-webkit-margin-before:0;-webkit-margin-after:0;-webkit-margin-start:0;-webkit-margin-end:0}kbd{border:1px solid #aaa;-moz-border-radius:2px;-webkit-border-radius:2px;border-radius:2px;-moz-box-shadow:1px 2px 2px #ddd;-webkit-box-shadow:1px 2px 2px #ddd;box-shadow:1px 2px 2px #ddd;background-color:#f9f9f9;background-image:-moz-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-o-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-webkit-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:linear-gradient(top,#eee,#f9f9f9,#eee);padding:1px 3px;font-family:inherit;font-size:.85em}.oembeded .oembed_photo{display:inline-block}img[data-echo]{margin:25px 0;width:100px;height:100px;background:#fff url(../img/ajax.gif) no-repeat center center}.spinner{display:inline-block;width:10px;height:10px;margin-bottom:-.1em;border:2px solid rgba(0,0,0,.5);border-top-color:transparent;border-radius:100%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear}.spinner:after{content:'';display:block;width:0;height:0;position:absolute;top:-6px;left:0;border:4px solid transparent;border-bottom-color:rgba(0,0,0,.5);-webkit-transform:rotate(45deg);transform:rotate(45deg)}@-webkit-keyframes spin{to{-webkit-transform:rotate(360deg)}}@keyframes spin{to{transform:rotate(360deg)}}p.toc{margin:0!important}p.toc ul{padding-left:10px}p.toc>ul{padding:10px;margin:0 10px;display:inline-block;border:1px solid #ededed;border-radius:5px}p.toc li,p.toc ul{list-style-type:none}p.toc li{width:100%;padding:0;overflow:hidden}p.toc li a::after{content:"."}p.toc li a:before{content:"• "}p.toc h5{text-transform:uppercase}p.toc .title{float:left;padding-right:3px}p.toc .number{margin:0;float:right;padding-left:3px;background:#fff;display:none}.markdown{padding:20px}.markdown a{text-decoration:none;vertical-align:baseline}.markdown a:hover{text-decoration:underline}.markdown h1{font-size:2.2em;font-weight:700;margin:1.5em 0 1em}.markdown h2{font-size:1.8em;font-weight:700;margin:1.275em 0 .85em}.markdown h3{font-size:1.6em;font-weight:700;margin:1.125em 0 .75em}.markdown h4{font-size:1.4em;font-weight:700;margin:.99em 0 .66em}.markdown h5{font-size:1.2em;font-weight:700;margin:.855em 0 .57em}.markdown h6{font-size:1em;font-weight:700;margin:.75em 0 .5em}.markdown h1+p,.markdown h1:first-child,.markdown h2+p,.markdown h2:first-child,.markdown h3+p,.markdown h3:first-child,.markdown h4+p,.markdown h4:first-child,.markdown h5+p,.markdown h5:first-child,.markdown h6+p,.markdown h6:first-child{margin-top:0}.markdown hr{border:1px solid #ccc}.markdown p{margin:1em 0;word-wrap:break-word}.markdown ol{list-style-type:decimal}.markdown li{display:list-item;line-height:1.4em}.markdown blockquote{margin:1em 20px}.markdown blockquote>:first-child{margin-top:0}.markdown blockquote>:last-child{margin-bottom:0}.markdown blockquote cite:before{content:'\2014 \00A0'}.markdown .code{border-radius:3px;word-break:break-all;word-wrap:break-word}.markdown pre{border-radius:3px;word-break:break-all;word-wrap:break-word;overflow:auto}.markdown pre code{display:block}.markdown pre>code{border:1px solid #ccc;white-space:pre;padding:.5em;margin:0}.markdown code{border-radius:3px;word-break:break-all;word-wrap:break-word;border:1px solid #ccc;padding:0 5px;margin:0 2px}.markdown img{max-width:100%}.markdown table{padding:0;border-collapse:collapse;border-spacing:0}.markdown table tr td,.markdown table tr th{border:1px solid #ccc;margin:0;padding:6px 13px}.markdown table tr th{font-weight:700}.markdown table tr th>:first-child{margin-top:0}.markdown table tr th>:last-child{margin-bottom:0}.markdown table tr td>:first-child{margin-top:0}.markdown table tr td>:last-child{margin-bottom:0}.markdown em.underline{font-style:normal;text-decoration:underline}.markdown strong.highlight{color:#000;padding:0 5px;background-color:#fdffb6;-webkit-box-shadow:#fdffb6 0 0 5px;-moz-box-shadow:#fdffb6 0 0 5px;box-shadow:#fdffb6 0 0 5px}@import url(http://fonts.googleapis.com/css?family=Tauri);import url(http://fonts.googleapis.com/css?family=Roboto+Condensed:300italic,400italic,700italic,400,300,700);.haroopad{padding:20px;color:#222;font-size:15px;font-family:'Roboto Condensed',Tauri,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",AppleSDGothicNeo-Medium,'Segoe UI','Malgun Gothic',Verdana,Tahoma,sans-serif;background:#fff;-webkit-font-smoothing:antialiased}.haroopad a{color:#3269a0}.haroopad a:hover{color:#4183c4}.haroopad h2{border-bottom:1px solid #e6e6e6;line-height:1.7em}.haroopad h6{color:#777}.haroopad hr{border:1px solid #e6e6e6}.haroopad blockquote>code,.haroopad h1>code,.haroopad h2>code,.haroopad h3>code,.haroopad h4>code,.haroopad h5>code,.haroopad h6>code,.haroopad li>code,.haroopad p>code,.haroopad td>code{color:#000;background-color:#feecdd;border:1px solid #efdfd0}.haroopad pre>code{font-size:1em;font-family:Consolas,Inconsolata,Courier,monospace;letter-spacing:-1px;font-weight:700}.haroopad blockquote{border-left:4px solid #e6e6e6;padding:0 15px;color:#777}.haroopad table{background-color:#fafafa}.haroopad table tr td,.haroopad table tr th{border:1px solid #e6e6e6}.haroopad table tr:nth-child(2n){background-color:#f2f2f2}.hljs-comment,.hljs-title{color:#999580}.css .hljs-class,.css .hljs-id,.css .hljs-pseudo,.hljs-attribute,.hljs-regexp,.hljs-tag,.hljs-variable,.html .hljs-doctype,.ruby .hljs-constant,.xml .hljs-doctype,.xml .hljs-pi,.xml .hljs-tag .hljs-title{color:#d73737}.hljs-built_in,.hljs-constant,.hljs-literal,.hljs-number,.hljs-params,.hljs-pragma,.hljs-preprocessor{color:#b65611}.css .hljs-rules .hljs-attribute,.ruby .hljs-class .hljs-title{color:#cfb017}.hljs-header,.hljs-inheritance,.hljs-string,.hljs-value,.ruby .hljs-symbol,.xml .hljs-cdata{color:#60ac39}.css .hljs-hexcolor{color:#1fad83}.coffeescript .hljs-title,.hljs-function,.javascript .hljs-title,.perl .hljs-sub,.python .hljs-decorator,.python .hljs-title,.ruby .hljs-function .hljs-title,.ruby .hljs-title .hljs-keyword{color:#6684e1}.hljs-keyword,.javascript .hljs-function{color:#b854d4}.hljs{display:block;background:#292824;color:#a6a28c;padding:.5em}.coffeescript .javascript,.javascript .xml,.tex .hljs-formula,.xml .css,.xml .hljs-cdata,.xml .javascript,.xml .vbscript{opacity:.5}footer{position:fixed;font-size:.8em;text-align:right;bottom:0;margin-left:-25px;height:20px;width:100%}</style>
</head>
<body class="markdown haroopad">

  <p class="toc" style="undefined"></p><ul>
<li><ul>
<li><span class="title">
<a href="#3.-air-hockey" title="3. Air Hockey">3. Air Hockey</a>
</span>
<!--span class="number">
0
</span-->
<ul>
<li><span class="title">
<a href="#游戏配置" title="游戏配置">游戏配置</a>
</span>
<!--span class="number">
1
</span-->
<ul>
<li><span class="title">
<a href="#行动：创建游戏工程" title="行动：创建游戏工程">行动：创建游戏工程</a>
</span>
<!--span class="number">
2
</span-->
</li>
<li><span class="title">
<a href="#行动：应用规则" title="行动：应用规则">行动：应用规则</a>
</span>
<!--span class="number">
3
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#支持retina屏" title="支持retina屏">支持retina屏</a>
</span>
<!--span class="number">
4
</span-->
<ul>
<li><span class="title">
<a href="#行动：添加图片" title="行动：添加图片">行动：添加图片</a>
</span>
<!--span class="number">
5
</span-->
</li>
<li><span class="title">
<a href="#行动：添加retina支持" title="行动：添加Retina支持">行动：添加Retina支持</a>
</span>
<!--span class="number">
6
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#添加声效" title="添加声效">添加声效</a>
</span>
<!--span class="number">
7
</span-->
</li>
<li><span class="title">
<a href="#扩展`ccsprite`" title="扩展CCSprite">扩展CCSprite</a>
</span>
<!--span class="number">
8
</span-->
<ul>
<li><span class="title">
<a href="#行动：定义`gamesprite`" title="行动：定义GameSprite">行动：定义GameSprite</a>
</span>
<!--span class="number">
9
</span-->
</li>
<li><span class="title">
<a href="#行动：实现`gamesprite`" title="行动：实现GameSprite">行动：实现GameSprite</a>
</span>
<!--span class="number">
10
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#game-scene" title="game scene">game scene</a>
</span>
<!--span class="number">
11
</span-->
<ul>
<li><span class="title">
<a href="#行动：`gamelayer`接口" title="行动：GameLayer接口">行动：GameLayer接口</a>
</span>
<!--span class="number">
12
</span-->
</li>
<li><span class="title">
<a href="#行动：实现`init()`" title="行动：实现init()">行动：实现init()</a>
</span>
<!--span class="number">
13
</span-->
</li>
<li><span class="title">
<a href="#行动：处理多点触摸" title="行动：处理多点触摸">行动：处理多点触摸</a>
</span>
<!--span class="number">
14
</span-->
</li>
<li><span class="title">
<a href="#行动：主循环" title="行动：主循环">行动：主循环</a>
</span>
<!--span class="number">
15
</span-->
</li>
<li><span class="title">
<a href="#行动：更新分数" title="行动：更新分数">行动：更新分数</a>
</span>
<!--span class="number">
16
</span-->
</li>
</ul>
</li>
</ul>
</li>
<li><span class="title">
<a href="#4.-sky-defense" title="4. Sky Defense">4. Sky Defense</a>
</span>
<!--span class="number">
17
</span-->
<ul>
<li><span class="title">
<a href="#the-game-–-sky-defense" title="The game – Sky Defense">The game – Sky Defense</a>
</span>
<!--span class="number">
18
</span-->
<ul>
<li><span class="title">
<a href="#the-game-settings" title="The game settings">The game settings</a>
</span>
<!--span class="number">
19
</span-->
</li>
<li><span class="title">
<a href="#the-start-project" title="The start project">The start project</a>
</span>
<!--span class="number">
20
</span-->
</li>
<li><span class="title">
<a href="#adding-screen-support-for-a-universal-app" title="Adding screen support for a universal app">Adding screen support for a universal app</a>
</span>
<!--span class="number">
21
</span-->
</li>
<li><span class="title">
<a href="#添加背景音乐" title="添加背景音乐">添加背景音乐</a>
</span>
<!--span class="number">
22
</span-->
</li>
<li><span class="title">
<a href="#初始化游戏" title="初始化游戏">初始化游戏</a>
</span>
<!--span class="number">
23
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#使用sprite-sheets{{纹理贴图}}" title="使用sprite sheets{{纹理贴图}}">使用sprite sheets{{纹理贴图}}</a>
</span>
<!--span class="number">
24
</span-->
<ul>
<li><span class="title">
<a href="#行动：创建一个`ccspritebatchnode`" title="行动：创建一个CCSpriteBatchNode">行动：创建一个CCSpriteBatchNode</a>
</span>
<!--span class="number">
25
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#bitmap字体" title="Bitmap字体">Bitmap字体</a>
</span>
<!--span class="number">
26
</span-->
<ul>
<li><span class="title">
<a href="#行动：创建`cclabelbmfont`" title="行动：创建CCLabelBMFont">行动：创建CCLabelBMFont</a>
</span>
<!--span class="number">
27
</span-->
</li>
<li><span class="title">
<a href="#行动：添加最终的屏幕精灵" title="行动：添加最终的屏幕精灵">行动：添加最终的屏幕精灵</a>
</span>
<!--span class="number">
28
</span-->
</li>
<li><span class="title">
<a href="#行动：创建对象池" title="行动：创建对象池">行动：创建对象池</a>
</span>
<!--span class="number">
29
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#ccactions" title="CCActions">CCActions</a>
</span>
<!--span class="number">
30
</span-->
<ul>
<li><span class="title">
<a href="#行动：创建actions" title="行动：创建Actions">行动：创建Actions</a>
</span>
<!--span class="number">
31
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#精灵动画" title="精灵动画">精灵动画</a>
</span>
<!--span class="number">
32
</span-->
<ul>
<li><span class="title">
<a href="#创建动画" title="创建动画">创建动画</a>
</span>
<!--span class="number">
33
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#令游戏运转" title="令游戏运转">令游戏运转</a>
</span>
<!--span class="number">
34
</span-->
<ul>
<li><span class="title">
<a href="#行动：处理触摸" title="行动：处理触摸">行动：处理触摸</a>
</span>
<!--span class="number">
35
</span-->
</li>
<li><span class="title">
<a href="#行动：开始和重启游戏" title="行动：开始和重启游戏">行动：开始和重启游戏</a>
</span>
<!--span class="number">
36
</span-->
</li>
<li><span class="title">
<a href="#行动：更新游戏" title="行动：更新游戏">行动：更新游戏</a>
</span>
<!--span class="number">
37
</span-->
</li>
<li><span class="title">
<a href="#从池中获取对象" title="从池中获取对象">从池中获取对象</a>
</span>
<!--span class="number">
38
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#玩游戏！" title="玩游戏！">玩游戏！</a>
</span>
<!--span class="number">
39
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#5-rock-thought" title="5 Rock thought">5 Rock thought</a>
</span>
<!--span class="number">
40
</span-->
<ul>
<li><span class="title">
<a href="#the-game-–-rocket-through" title="The game – Rocket Through">The game – Rocket Through</a>
</span>
<!--span class="number">
41
</span-->
<ul>
<li><span class="title">
<a href="#the-game-settings-1" title="The game settings">The game settings</a>
</span>
<!--span class="number">
42
</span-->
</li>
<li><span class="title">
<a href="#play-first,-work-later" title="Play first, work later">Play first, work later</a>
</span>
<!--span class="number">
43
</span-->
</li>
<li><span class="title">
<a href="#the-start-project-1" title="The start project">The start project</a>
</span>
<!--span class="number">
44
</span-->
</li>
<li><span class="title">
<a href="#屏幕设置" title="屏幕设置">屏幕设置</a>
</span>
<!--span class="number">
45
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#什么是粒子" title="什么是粒子">什么是粒子</a>
</span>
<!--span class="number">
46
</span-->
<ul>
<li><span class="title">
<a href="#行动：创建粒子系统" title="行动：创建粒子系统">行动：创建粒子系统</a>
</span>
<!--span class="number">
47
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#创建网格" title="创建网格">创建网格</a>
</span>
<!--span class="number">
48
</span-->
</li>
<li><span class="title">
<a href="#绘制基本图形" title="绘制基本图形">绘制基本图形</a>
</span>
<!--span class="number">
49
</span-->
<ul>
<li><span class="title">
<a href="#行动：绘制" title="行动：绘制">行动：绘制</a>
</span>
<!--span class="number">
50
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#火箭精灵" title="火箭精灵">火箭精灵</a>
</span>
<!--span class="number">
51
</span-->
<ul>
<li><span class="title">
<a href="#行动：更新火箭" title="行动：更新火箭">行动：更新火箭</a>
</span>
<!--span class="number">
52
</span-->
</li>
<li><span class="title">
<a href="#行动：处理触摸-1" title="行动：处理触摸">行动：处理触摸</a>
</span>
<!--span class="number">
53
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#游戏循环" title="游戏循环">游戏循环</a>
</span>
<!--span class="number">
54
</span-->
</li>
<li><span class="title">
<a href="#kill-and-reset" title="Kill and reset">Kill and reset</a>
</span>
<!--span class="number">
55
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#6-快速原型开发：rush-hour" title="6 快速原型开发：Rush Hour">6 快速原型开发：Rush Hour</a>
</span>
<!--span class="number">
56
</span-->
<ul>
<li><span class="title">
<a href="#游戏：victorian-rush-hour" title="游戏：Victorian Rush Hour">游戏：Victorian Rush Hour</a>
</span>
<!--span class="number">
57
</span-->
</li>
<li><span class="title">
<a href="#快速原型" title="快速原型">快速原型</a>
</span>
<!--span class="number">
58
</span-->
<ul>
<li><span class="title">
<a href="#行动：创建占位符精灵" title="行动：创建占位符精灵">行动：创建占位符精灵</a>
</span>
<!--span class="number">
59
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#player对象" title="Player对象">Player对象</a>
</span>
<!--span class="number">
60
</span-->
</li>
<li><span class="title">
<a href="#block对象" title="Block对象">Block对象</a>
</span>
<!--span class="number">
61
</span-->
</li>
<li><span class="title">
<a href="#terrain对象" title="Terrain对象">Terrain对象</a>
</span>
<!--span class="number">
62
</span-->
<ul>
<li><span class="title">
<a href="#行动：编写player" title="行动：编写Player">行动：编写Player</a>
</span>
<!--span class="number">
63
</span-->
</li>
<li><span class="title">
<a href="#行动：初始化`terrain`类" title="行动：初始化Terrain类">行动：初始化Terrain类</a>
</span>
<!--span class="number">
64
</span-->
</li>
<li><span class="title">
<a href="#行动：初始化blocks" title="行动：初始化Blocks">行动：初始化Blocks</a>
</span>
<!--span class="number">
65
</span-->
</li>
<li><span class="title">
<a href="#行动：移动和重置" title="行动：移动和重置">行动：移动和重置</a>
</span>
<!--span class="number">
66
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#平台碰撞检测逻辑" title="平台碰撞检测逻辑">平台碰撞检测逻辑</a>
</span>
<!--span class="number">
67
</span-->
</li>
<li><span class="title">
<a href="#添加控制" title="添加控制">添加控制</a>
</span>
<!--span class="number">
68
</span-->
<ul>
<li><span class="title">
<a href="#行动：处理触摸-2" title="行动：处理触摸">行动：处理触摸</a>
</span>
<!--span class="number">
69
</span-->
</li>
<li><span class="title">
<a href="#行动：主循环-1" title="行动：主循环">行动：主循环</a>
</span>
<!--span class="number">
70
</span-->
</li>
</ul>
</li>
</ul>
</li>
<li><span class="title">
<a href="#7-向victorian-rush-hour添加外观" title="7 向Victorian Rush Hour添加外观">7 向Victorian Rush Hour添加外观</a>
</span>
<!--span class="number">
71
</span-->
<ul>
<li><span class="title">
<a href="#victorian-rush-hour-–-the-game" title="Victorian Rush Hour – the game">Victorian Rush Hour – the game</a>
</span>
<!--span class="number">
72
</span-->
<ul>
<li><span class="title">
<a href="#新精灵" title="新精灵">新精灵</a>
</span>
<!--span class="number">
73
</span-->
</li>
<li><span class="title">
<a href="#动画" title="动画">动画</a>
</span>
<!--span class="number">
74
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#使用`ccsprite`给动画添加纹理" title="使用CCSprite给动画添加纹理">使用CCSprite给动画添加纹理</a>
</span>
<!--span class="number">
75
</span-->
</li>
<li><span class="title">
<a href="#containers-within-containers" title="Containers within containers">Containers within containers</a>
</span>
<!--span class="number">
76
</span-->
</li>
<li><span class="title">
<a href="#创建视察滚动特效" title="创建视察滚动特效">创建视察滚动特效</a>
</span>
<!--span class="number">
77
</span-->
</li>
<li><span class="title">
<a href="#添加游戏菜单" title="添加游戏菜单">添加游戏菜单</a>
</span>
<!--span class="number">
78
</span-->
</li>
<li><span class="title">
<a href="#添加教程" title="添加教程">添加教程</a>
</span>
<!--span class="number">
79
</span-->
</li>
</ul>
</li>
<li><span class="title">
<a href="#8-box2d" title="8 Box2D">8 Box2D</a>
</span>
<!--span class="number">
80
</span-->
<ul>
<li><span class="title">
<a href="#创建box2d工程" title="创建Box2D工程">创建Box2D工程</a>
</span>
<!--span class="number">
81
</span-->
</li>
<li><span class="title">
<a href="#什么是物理引擎" title="什么是物理引擎">什么是物理引擎</a>
</span>
<!--span class="number">
82
</span-->
<ul>
<li><span class="title">
<a href="#meet-box2d" title="Meet Box2D">Meet Box2D</a>
</span>
<!--span class="number">
83
</span-->
</li>
<li><span class="title">
<a href="#meet-the-world" title="Meet the world">Meet the world</a>
</span>
<!--span class="number">
84
</span-->
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>

</ul>
<p></p><h2 id="3.-air-hockey"><a name="3.-air-hockey" href="#3.-air-hockey"></a>3. Air Hockey</h2><p>内容介绍：setting up the project’s configuration, loading images, loading sounds, building a game for more than one screen resolution, and managing touch events.</p><p>这个游戏是双人游戏。</p><h3 id="游戏配置"><a name="游戏配置" href="#游戏配置"></a>游戏配置</h3><p>游戏特征：</p><ul>
<li>支持多点触摸，因为是双人游戏</li>
<li>在大屏上玩</li>
<li>支持retina屏</li>
<li>屏幕水平</li>
</ul><h4 id="行动：创建游戏工程"><a name="行动：创建游戏工程" href="#行动：创建游戏工程"></a>行动：创建游戏工程</h4><p>接下来将使用Xcode创建所有工程：</p><ol>
<li>Open Xcode and create a new project with the Cocos2d-x basic template.</li>
<li>Call it Air Hockey, and set its <strong>Device Family</strong> to iPad.</li>
</ol><h4 id="行动：应用规则"><a name="行动：应用规则" href="#行动：应用规则"></a>行动：应用规则</h4><p>更新<code>AppController.mm</code>和<code>RootViewController.mm</code>：</p><p>Go to <code>AppController.mm</code> and inside the <code>(BOOL) application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code> method below the section where the <code>EAGLView *__glView</code> object is instantiated, write this line: <code>[__glView setMultipleTouchEnabled:YES];</code>（支持多点）</p><p>Now go to <code>RootViewController.mm</code> and look for the <code>shouldAutorotateToInterfaceOrientation</code> method. Change the line inside the method to read:<br><code>return UIInterfaceOrientationIsPortrait( interfaceOrientation );</code></p><p>Finally, a few lines below in the <code>supportedInterfaceOrientations</code> method change the line inside the conditional to: <code>return UIInterfaceOrientationMaskPortrait;</code></p><h3 id="支持retina屏"><a name="支持retina屏" href="#支持retina屏"></a>支持retina屏</h3><h4 id="行动：添加图片"><a name="行动：添加图片" href="#行动：添加图片"></a>行动：添加图片</h4><p>打开<code>7341_03_RESOURCES.zip</code>。里面有两个文件夹分别是<code>hd</code>和<code>sd</code>，分别用于retina屏和非retina屏。将这两个文件夹拖动你工程的<code>Resources</code>文件夹。</p><p>Go back to Xcode. Select the Resources folder in your project navigation panel. Then go to <code>File| Add Files</code> to Air Hockey.</p><p>In the File window navigate to the Resources folder and select both the sd and hd folders. This is very important: Make sure Create folder references for any added folders is selected. Also make sure you selected Air Hockey as the target. It wouldn’t hurt to make sure <strong>Copy items to destination…</strong> is also selected. Click Add.</p><p>It is very important that references are added to the actual folders, only in this way will Xcode be able to have two files with the same name inside the project and still keep them apart; one in each folder.</p><h4 id="行动：添加retina支持"><a name="行动：添加retina支持" href="#行动：添加retina支持"></a>行动：添加Retina支持</h4><p>修改<code>AppDelegate.cpp</code>类。向<code>applicationDidFinishLaunching</code>方法，<code>pDirector-&gt;setOpenGLView( pEGLView)</code>之下添加：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    CCSize screenSize = pEGLView-&amp;gt;getFrameSize();
    CCEGLView::sharedOpenGLView()-&amp;gt;setDesignResolutionSize(768, 1024, kResolutionExactFit);
    if (screenSize.width &amp;gt; 768) {
        CCFileUtils::sharedFileUtils()-&amp;gt;setResourceDirectory(&quot;hd&quot;);
        pDirector-&amp;gt;setContentScaleFactor(2);
    } else {
        CCFileUtils::sharedFileUtils()-&amp;gt;setResourceDirectory(&quot;sd&quot;);
        pDirector-&amp;gt;setContentScaleFactor(1);
    }
&lt;/code&gt;&lt;/pre&gt;">    CCSize screenSize = pEGLView-&gt;getFrameSize();
    CCEGLView::sharedOpenGLView()-&gt;setDesignResolutionSize(<span class="hljs-number">768</span>, <span class="hljs-number">1024</span>, kResolutionExactFit);
    <span class="hljs-keyword">if</span> (screenSize.width &gt; <span class="hljs-number">768</span>) {
        CCFileUtils::sharedFileUtils()-&gt;setResourceDirectory(<span class="hljs-string">"hd"</span>);
        pDirector-&gt;setContentScaleFactor(<span class="hljs-number">2</span>);
    } <span class="hljs-keyword">else</span> {
        CCFileUtils::sharedFileUtils()-&gt;setResourceDirectory(<span class="hljs-string">"sd"</span>);
        pDirector-&gt;setContentScaleFactor(<span class="hljs-number">1</span>);
    }
</code></pre><p><code>setDesignResolutionSize</code>表达了，我设计游戏时使用的分辨率是<code>768 x 1024</code>。即所有的定位与字体都相对于这个分辨率。</p><p><code>CCFileUtils</code>会先在<strong>rces| sd (or hd)</strong>中寻找资源，如果找不到，再在Resources中找。即两个分辨率都一样的文件可以放在Resources中，不用重复两份。例如声音文件。</p><h3 id="添加声效"><a name="添加声效" href="#添加声效"></a>添加声效</h3><p>将<code>.wav</code>拖动到你的工程的<code>Resources</code>文件夹。Then go to Xcode, select the Resources folder in the file navigation panel and select <strong>File | Add Files</strong> to Air Hockey. Make sure the Air Hockey target is selected. Add the <strong>wav</strong> files.</p><p>在<code>AppDelegate.cpp</code>顶部添加：<code>#include "SimpleAudioEngine.h"</code>。在<code>USING_NS_CC</code>下添加：<code>using namespace CocosDenshion;</code>。</p><p>在<code>applicationDidFinishLaunching</code>方法，上一节添加的内容之下添加：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    SimpleAudioEngine::sharedEngine()-&amp;gt;preloadEffect(
        CCFileUtils::sharedFileUtils()-&amp;gt;fullPathFromRelativePath(&quot;hit.wav&quot;) );
    SimpleAudioEngine::sharedEngine()-&amp;gt;preloadEffect(
        CCFileUtils::sharedFileUtils()-&amp;gt;fullPathFromRelativePath(&quot;score.wav&quot;) );
&lt;/code&gt;&lt;/pre&gt;">    SimpleAudioEngine::sharedEngine()-&gt;preloadEffect(
        CCFileUtils::sharedFileUtils()-&gt;fullPathFromRelativePath(<span class="hljs-string">"hit.wav"</span>) );
    SimpleAudioEngine::sharedEngine()-&gt;preloadEffect(
        CCFileUtils::sharedFileUtils()-&gt;fullPathFromRelativePath(<span class="hljs-string">"score.wav"</span>) );
</code></pre><p>加载声音很费时，因此尽早做。</p><h3 id="扩展`ccsprite`"><a name="扩展`ccsprite`" href="#扩展`ccsprite`"></a>扩展<code>CCSprite</code></h3><p>我们需要一些额外的信息，因此扩展<code>CCSprite</code>。</p><h4 id="行动：定义`gamesprite`"><a name="行动：定义`gamesprite`" href="#行动：定义`gamesprite`"></a>行动：定义<code>GameSprite</code></h4><p>GameSprite.h：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    #ifndef __GAMESPRITE_H__
    #define __GAMESPRITE_H__
    #include &quot;cocos2d.h&quot;
    using namespace cocos2d;
    class GameSprite : public CCSprite {
    public:
        CC_SYNTHESIZE(CCPoint, _nextPosition, NextPosition);
        CC_SYNTHESIZE(CCPoint, _vector, Vector);
        CC_SYNTHESIZE(CCTouch *, _touch, Touch);
        GameSprite(void);
        ~GameSprite(void);
        static GameSprite* gameSpriteWithFile(const char *pszFileName);
        virtual void setPosition(const CCPoint&amp;amp; pos);
        float radius();
    };
    #endif // __GAMESPRITE_H__
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-preprocessor">#ifndef __GAMESPRITE_H__</span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> __GAMESPRITE_H__</span>
    <span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> "cocos2d.h"</span>
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cocos2d;
    <span class="hljs-keyword">class</span> GameSprite : <span class="hljs-keyword">public</span> CCSprite {
    <span class="hljs-keyword">public</span>:
        CC_SYNTHESIZE(CCPoint, _nextPosition, NextPosition);
        CC_SYNTHESIZE(CCPoint, _vector, Vector);
        CC_SYNTHESIZE(CCTouch *, _touch, Touch);
        GameSprite(<span class="hljs-keyword">void</span>);
        ~GameSprite(<span class="hljs-keyword">void</span>);
        <span class="hljs-keyword">static</span> GameSprite* gameSpriteWithFile(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pszFileName);
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> setPosition(<span class="hljs-keyword">const</span> CCPoint&amp; pos);
        <span class="hljs-keyword">float</span> radius();
    };
    <span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// __GAMESPRITE_H__</span></span>
</code></pre><p>利用宏创建三个合成（synthesized）属性：利用宏创建getter和setter方法。You declare the type, the <code>protected</code> variable name, and the words that will be appended to the get and set methods.</p><p><code>gameSpriteWithFile</code>用于实例化。</p><h4 id="行动：实现`gamesprite`"><a name="行动：实现`gamesprite`" href="#行动：实现`gamesprite`"></a>行动：实现<code>GameSprite</code></h4><p><code>GameSprite.cpp</code>：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    #include &quot;GameSprite.h&quot;
    GameSprite::GameSprite(void) {
        _vector = ccp(0,0);
    }
    GameSprite::~GameSprite(void) {
    }
    GameSprite* GameSprite::gameSpriteWithFile(const char *pszFileName) {
        GameSprite *sprite = new GameSprite();
        if (sprite &amp;amp;&amp;amp; sprite-&amp;gt;initWithFile(pszFileName)) {
            sprite-&amp;gt;autorelease();
            return sprite;
        }
        CC_SAFE_DELETE(sprite);
        return NULL;
    }

    float GameSprite::radius() {
        return getTexture()-&amp;gt;getContentSize().width * 0.5f;
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> "GameSprite.h"</span>
    GameSprite::GameSprite(<span class="hljs-keyword">void</span>) {
        _vector = ccp(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);
    }
    GameSprite::~GameSprite(<span class="hljs-keyword">void</span>) {
    }
    GameSprite* GameSprite::gameSpriteWithFile(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pszFileName) {
        GameSprite *sprite = <span class="hljs-keyword">new</span> GameSprite();
        <span class="hljs-keyword">if</span> (sprite &amp;&amp; sprite-&gt;initWithFile(pszFileName)) {
            sprite-&gt;autorelease();
            <span class="hljs-keyword">return</span> sprite;
        }
        CC_SAFE_DELETE(sprite);
        <span class="hljs-keyword">return</span> NULL;
    }

    <span class="hljs-keyword">float</span> GameSprite::radius() {
        <span class="hljs-keyword">return</span> getTexture()-&gt;getContentSize().width * <span class="hljs-number">0.5f</span>;
    }
</code></pre><p>覆盖<code>CCNode</code>的<code>setPosition</code>方法。为的是，改变位置后，新值更新到<code>_nextPosition</code>：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void GameSprite::setPosition(const CCPoint&amp;amp; pos) {
        CCSprite::setPosition(pos);
        if (!_nextPosition.equals(pos)) {
            _nextPosition = pos;
        }
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> GameSprite::setPosition(<span class="hljs-keyword">const</span> CCPoint&amp; pos) {
        CCSprite::setPosition(pos);
        <span class="hljs-keyword">if</span> (!_nextPosition.equals(pos)) {
            _nextPosition = pos;
        }
    }
</code></pre><h3 id="game-scene"><a name="game-scene" href="#game-scene"></a>game scene</h3><p>Rename the <code>HelloWorldScene</code> files to <code>GameLayer</code>, and the class inside them from <code>HelloWorld</code> to <code>GameLayer</code>. References to the class must be changed in two lines of <code>AppDelegate.cpp</code>, and also the <code>include</code> statement at the top of <code>HelloWorldScene.cpp</code>. Of course, any scope resolution changes (the <code>HelloWorld::</code> funny bits) must be changed in <code>HelloWorldScene.cpp</code> as well.</p><h4 id="行动：`gamelayer`接口"><a name="行动：`gamelayer`接口" href="#行动：`gamelayer`接口"></a>行动：<code>GameLayer</code>接口</h4><p>修改<code>GameLayer.h</code>。替换为</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    #ifndef __GAMELAYER_H__
        #define __GAMELAYER_H__
        #define GOAL_WIDTH 400 // 球门宽度

        #include &quot;cocos2d.h&quot;
        #include &quot;GameSprite.h&quot;
        using namespace cocos2d;

        class GameLayer : public cocos2d::CCLayer
        {
            GameSprite * _player1;
            GameSprite * _player2;
            GameSprite * _ball;
            CCArray * _players;
            CCLabelTTF * _player1ScoreLabel;
            CCLabelTTF * _player2ScoreLabel;

            CCSize _screenSize; // 因为经常使用，存下来

            // 得分与更新得分的方法
            int _player1Score;
            int _player2Score;
            void playerScore (int player);

        public:
            ~GameLayer();
            virtual bool init();
            static CCScene* scene();
            CREATE_FUNC(GameLayer);
            virtual void ccTouchesBegan(CCSet* pTouches, CCEvent* event);
            virtual void ccTouchesMoved(CCSet* pTouches, CCEvent* event);
            virtual void ccTouchesEnded(CCSet* pTouches, CCEvent* event);
            void update (float dt); // 普通成员方法，不是父类中的
        };
    #endif // __GAMELAYER_H__
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-preprocessor">#ifndef __GAMELAYER_H__</span>
        <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> __GAMELAYER_H__</span>
        <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> GOAL_WIDTH 400 <span class="hljs-comment">// 球门宽度</span></span>

        <span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> "cocos2d.h"</span>
        <span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> "GameSprite.h"</span>
        <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> cocos2d;

        <span class="hljs-keyword">class</span> GameLayer : <span class="hljs-keyword">public</span> cocos2d::CCLayer
        {
            GameSprite * _player1;
            GameSprite * _player2;
            GameSprite * _ball;
            CCArray * _players;
            CCLabelTTF * _player1ScoreLabel;
            CCLabelTTF * _player2ScoreLabel;

            CCSize _screenSize; <span class="hljs-comment">// 因为经常使用，存下来</span>

            <span class="hljs-comment">// 得分与更新得分的方法</span>
            <span class="hljs-keyword">int</span> _player1Score;
            <span class="hljs-keyword">int</span> _player2Score;
            <span class="hljs-keyword">void</span> playerScore (<span class="hljs-keyword">int</span> player);

        <span class="hljs-keyword">public</span>:
            ~GameLayer();
            <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> init();
            <span class="hljs-keyword">static</span> CCScene* scene();
            CREATE_FUNC(GameLayer);
            <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> ccTouchesBegan(CCSet* pTouches, CCEvent* event);
            <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> ccTouchesMoved(CCSet* pTouches, CCEvent* event);
            <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> ccTouchesEnded(CCSet* pTouches, CCEvent* event);
            <span class="hljs-keyword">void</span> update (<span class="hljs-keyword">float</span> dt); <span class="hljs-comment">// 普通成员方法，不是父类中的</span>
        };
    <span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// __GAMELAYER_H__</span></span>
</code></pre><h4 id="行动：实现`init()`"><a name="行动：实现`init()`" href="#行动：实现`init()`"></a>行动：实现<code>init()</code></h4><p>在调用父类方法<code>CCLayer::init</code>之后，添加：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    _player1Score = 0;
    _player2Score = 0;
    _screenSize = CCDirector::sharedDirector()-&amp;gt;getWinSize();
&lt;/code&gt;&lt;/pre&gt;">    _player1Score = <span class="hljs-number">0</span>;
    _player2Score = <span class="hljs-number">0</span>;
    _screenSize = CCDirector::sharedDirector()-&gt;getWinSize();
</code></pre><p>屏幕大小将用于定位精灵。</p><p>加载第一个精灵：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    CCSprite * court = CCSprite::create(&quot;court.png&quot;);
    court-&amp;gt;setPosition(ccp(_screenSize.width * 0.5, _screenSize.height * 0.5));
    this-&amp;gt;addChild(court);
&lt;/code&gt;&lt;/pre&gt;">    CCSprite * court = CCSprite::create(<span class="hljs-string">"court.png"</span>);
    court-&gt;setPosition(ccp(_screenSize.width * <span class="hljs-number">0.5</span>, _screenSize.height * <span class="hljs-number">0.5</span>));
    <span class="hljs-keyword">this</span>-&gt;addChild(court);
</code></pre><p>宏<code>ccp</code>用于创建点。</p><p>创建<code>GameSprite</code>精灵：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    _player1 = GameSprite::gameSpriteWithFile(&quot;mallet.png&quot;);
    _player1-&amp;gt;setPosition(ccp(_screenSize.width * 0.5,
        _player1-&amp;gt;radius() * 2));
    this-&amp;gt;addChild(_player1);

    _player2 = GameSprite::gameSpriteWithFile(&quot;mallet.png&quot;);
    _player2-&amp;gt;setPosition(ccp(_screenSize.width * 0.5,
        _screenSize.height - _player1-&amp;gt;radius() * 2));
    this-&amp;gt;addChild(_player2);

    _ball = GameSprite::gameSpriteWithFile(&quot;puck.png&quot;);
    // 球的位置偏下，不在中线上
    _ball-&amp;gt;setPosition(ccp(_screenSize.width * 0.5,
        _screenSize.height * 0.5 - 2 * _ball-&amp;gt;radius()));
    this-&amp;gt;addChild(_ball);
&lt;/code&gt;&lt;/pre&gt;">    _player1 = GameSprite::gameSpriteWithFile(<span class="hljs-string">"mallet.png"</span>);
    _player1-&gt;setPosition(ccp(_screenSize.width * <span class="hljs-number">0.5</span>,
        _player1-&gt;radius() * <span class="hljs-number">2</span>));
    <span class="hljs-keyword">this</span>-&gt;addChild(_player1);

    _player2 = GameSprite::gameSpriteWithFile(<span class="hljs-string">"mallet.png"</span>);
    _player2-&gt;setPosition(ccp(_screenSize.width * <span class="hljs-number">0.5</span>,
        _screenSize.height - _player1-&gt;radius() * <span class="hljs-number">2</span>));
    <span class="hljs-keyword">this</span>-&gt;addChild(_player2);

    _ball = GameSprite::gameSpriteWithFile(<span class="hljs-string">"puck.png"</span>);
    <span class="hljs-comment">// 球的位置偏下，不在中线上</span>
    _ball-&gt;setPosition(ccp(_screenSize.width * <span class="hljs-number">0.5</span>,
        _screenSize.height * <span class="hljs-number">0.5</span> - <span class="hljs-number">2</span> * _ball-&gt;radius()));
    <span class="hljs-keyword">this</span>-&gt;addChild(_ball);
</code></pre><p>We create a <code>CCArray</code> method to store the player objects and we <strong>retain</strong> this array to keep a reference to it throughout the game:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    _players = CCArray::create(_player1, _player2, NULL);
    _players-&amp;gt;retain();
&lt;/code&gt;&lt;/pre&gt;">    _players = CCArray::create(_player1, _player2, NULL);
    _players-&gt;retain();
</code></pre><p>利用<code>CCLabelTTF</code>创建标签。once again the font size will be automatically scaled in the high definition version。</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    _player1ScoreLabel = CCLabelTTF::create(&quot;0&quot;, &quot;Arial&quot;, 60);
    _player1ScoreLabel-&amp;gt;setPosition(ccp(_screenSize.width - 60,
        _screenSize.height * 0.5 - 80));
    _player1ScoreLabel-&amp;gt;setRotation(90);
    this-&amp;gt;addChild(_player1ScoreLabel);

    _player2ScoreLabel = CCLabelTTF::create(&quot;0&quot;, &quot;Arial&quot;, 60);
    _player2ScoreLabel-&amp;gt;setPosition(ccp(_screenSize.width - 60,
        _screenSize.height * 0.5 + 80));
    _player2ScoreLabel-&amp;gt;setRotation(90);
    this-&amp;gt;addChild(_player2ScoreLabel);
&lt;/code&gt;&lt;/pre&gt;">    _player1ScoreLabel = CCLabelTTF::create(<span class="hljs-string">"0"</span>, <span class="hljs-string">"Arial"</span>, <span class="hljs-number">60</span>);
    _player1ScoreLabel-&gt;setPosition(ccp(_screenSize.width - <span class="hljs-number">60</span>,
        _screenSize.height * <span class="hljs-number">0.5</span> - <span class="hljs-number">80</span>));
    _player1ScoreLabel-&gt;setRotation(<span class="hljs-number">90</span>);
    <span class="hljs-keyword">this</span>-&gt;addChild(_player1ScoreLabel);

    _player2ScoreLabel = CCLabelTTF::create(<span class="hljs-string">"0"</span>, <span class="hljs-string">"Arial"</span>, <span class="hljs-number">60</span>);
    _player2ScoreLabel-&gt;setPosition(ccp(_screenSize.width - <span class="hljs-number">60</span>,
        _screenSize.height * <span class="hljs-number">0.5</span> + <span class="hljs-number">80</span>));
    _player2ScoreLabel-&gt;setRotation(<span class="hljs-number">90</span>);
    <span class="hljs-keyword">this</span>-&gt;addChild(_player2ScoreLabel);
</code></pre><p>Label objects (<code>CCLabelTTF</code>) can use any of the fonts supported by the target system; these change from system to system, however. But there is an option of loading your own TTF files.</p><p>最后，声明<code>CCLayer</code>允许监听触摸事件。并开始排期主循环：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    // listen for touches
    this-&amp;gt;setTouchEnabled(true);
    // create main loop
    this-&amp;gt;schedule(schedule_selector(GameLayer::update));
    return true;
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-comment">// listen for touches</span>
    <span class="hljs-keyword">this</span>-&gt;setTouchEnabled(<span class="hljs-keyword">true</span>);
    <span class="hljs-comment">// create main loop</span>
    <span class="hljs-keyword">this</span>-&gt;schedule(schedule_selector(GameLayer::update));
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
</code></pre><p>在析构器中释放之前retain的数组：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    GameLayer::~GameLayer() {
        CC_SAFE_RELEASE(_players);
    }
&lt;/code&gt;&lt;/pre&gt;">    GameLayer::~GameLayer() {
        CC_SAFE_RELEASE(_players);
    }
</code></pre><p><img src="ch3-demo-1.png" alt=""></p><h4 id="行动：处理多点触摸"><a name="行动：处理多点触摸" href="#行动：处理多点触摸"></a>行动：处理多点触摸</h4><p><code>ccTouchesBegan</code>方法：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void GameLayer::ccTouchesBegan(CCSet* pTouches, CCEvent* event) {
        CCSetIterator i;
        CCTouch* touch;
        CCPoint tap;
        GameSprite * player;
        for( i = pTouches-&amp;gt;begin(); i != pTouches-&amp;gt;end(); i++) {
            touch = (CCTouch*) (*i);
            if(touch) {
                tap = touch-&amp;gt;getLocation();
                for (int p = 0; p &amp;lt; 2; p++) {
                    player = (GameSprite *) _players-&amp;gt;objectAtIndex(p);
                    if (player-&amp;gt;boundingBox().containsPoint(tap)) {
                        player-&amp;gt;setTouch(touch);
                    }
                }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> GameLayer::ccTouchesBegan(CCSet* pTouches, CCEvent* event) {
        CCSetIterator i;
        CCTouch* touch;
        CCPoint tap;
        GameSprite * player;
        <span class="hljs-keyword">for</span>( i = pTouches-&gt;begin(); i != pTouches-&gt;end(); i++) {
            touch = (CCTouch*) (*i);
            <span class="hljs-keyword">if</span>(touch) {
                tap = touch-&gt;getLocation();
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>; p &lt; <span class="hljs-number">2</span>; p++) {
                    player = (GameSprite *) _players-&gt;objectAtIndex(p);
                    <span class="hljs-keyword">if</span> (player-&gt;boundingBox().containsPoint(tap)) {
                        player-&gt;setTouch(touch);
                    }
                }
            }
        }
    }
</code></pre><p>每个<code>GameSprite</code>都有一个<code>_touch</code>属性。如果触摸了某个精灵，就将<code>touch</code>存到其<code>_touch</code>属性中去。</p><p><code>ccTouchesMoved</code>方法（外层略）：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    for (int p = 0; p &amp;lt; _players-&amp;gt;count(); p++) {
        player = (GameSprite *) _players-&amp;gt;objectAtIndex(p);
        if (player-&amp;gt;getTouch() != NULL &amp;amp;&amp;amp; player-&amp;gt;getTouch() == touch) {
        CCPoint nextPosition = tap;
        // 不能移出屏幕
        if (nextPosition.x &amp;lt; player-&amp;gt;radius())
            nextPosition.x = player-&amp;gt;radius();
        if (nextPosition.x &amp;gt; _screenSize.width - player-&amp;gt;radius())
            nextPosition.x = _screenSize.width - player-&amp;gt;radius();
        if (nextPosition.y &amp;lt; player-&amp;gt;radius())
            nextPosition.y = player-&amp;gt;radius();
        if (nextPosition.y &amp;gt; _screenSize.height - player-&amp;gt;radius())
            nextPosition.y = _screenSize.height - player-&amp;gt;radius();
        // 不能移出自己的半场
        if (player-&amp;gt;getPositionY() &amp;lt; _screenSize.height * 0.5f)
        {
            if (nextPosition.y &amp;gt;  _screenSize.height * 0.5 - player-&amp;gt;radius())
            {
                nextPosition.y = _screenSize.height * 0.5 - player-&amp;gt;radius();
            }
        } else {
            if (nextPosition.y &amp;lt; _screenSize.height * 0.5 + player-&amp;gt;radius())
            {
                nextPosition.y = _screenSize.height * 0.5 + player-&amp;gt;radius();
            }
        }

        player-&amp;gt;setNextPosition(nextPosition);
        player-&amp;gt;setVector(ccp(tap.x - player-&amp;gt;getPositionX(),
            tap.y - player-&amp;gt;getPositionY()));
        }
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>; p &lt; _players-&gt;count(); p++) {
        player = (GameSprite *) _players-&gt;objectAtIndex(p);
        <span class="hljs-keyword">if</span> (player-&gt;getTouch() != NULL &amp;&amp; player-&gt;getTouch() == touch) {
        CCPoint nextPosition = tap;
        <span class="hljs-comment">// 不能移出屏幕</span>
        <span class="hljs-keyword">if</span> (nextPosition.x &lt; player-&gt;radius())
            nextPosition.x = player-&gt;radius();
        <span class="hljs-keyword">if</span> (nextPosition.x &gt; _screenSize.width - player-&gt;radius())
            nextPosition.x = _screenSize.width - player-&gt;radius();
        <span class="hljs-keyword">if</span> (nextPosition.y &lt; player-&gt;radius())
            nextPosition.y = player-&gt;radius();
        <span class="hljs-keyword">if</span> (nextPosition.y &gt; _screenSize.height - player-&gt;radius())
            nextPosition.y = _screenSize.height - player-&gt;radius();
        <span class="hljs-comment">// 不能移出自己的半场</span>
        <span class="hljs-keyword">if</span> (player-&gt;getPositionY() &lt; _screenSize.height * <span class="hljs-number">0.5f</span>)
        {
            <span class="hljs-keyword">if</span> (nextPosition.y &gt;  _screenSize.height * <span class="hljs-number">0.5</span> - player-&gt;radius())
            {
                nextPosition.y = _screenSize.height * <span class="hljs-number">0.5</span> - player-&gt;radius();
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (nextPosition.y &lt; _screenSize.height * <span class="hljs-number">0.5</span> + player-&gt;radius())
            {
                nextPosition.y = _screenSize.height * <span class="hljs-number">0.5</span> + player-&gt;radius();
            }
        }

        player-&gt;setNextPosition(nextPosition);
        player-&gt;setVector(ccp(tap.x - player-&gt;getPositionX(),
            tap.y - player-&gt;getPositionY()));
        }
    }
</code></pre><p>精灵的<code>vector</code>会在碰撞检测时用到。</p><p><code>ccTouchesEnded</code>方法（外层略）：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    for (int p = 0; p &amp;lt; _players-&amp;gt;count(); p++) {
        player = (GameSprite *) _players-&amp;gt;objectAtIndex(p);
        if (player-&amp;gt;getTouch() != NULL &amp;amp;&amp;amp; player-&amp;gt;getTouch() == touch) {
            player-&amp;gt;setTouch(NULL);
            player-&amp;gt;setVector(ccp(0,0));
        }
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>; p &lt; _players-&gt;count(); p++) {
        player = (GameSprite *) _players-&gt;objectAtIndex(p);
        <span class="hljs-keyword">if</span> (player-&gt;getTouch() != NULL &amp;&amp; player-&gt;getTouch() == touch) {
            player-&gt;setTouch(NULL);
            player-&gt;setVector(ccp(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));
        }
    }
</code></pre><p>实现多点触摸的另一种方式是实现<code>CCTargetedTouchDelegate</code>协议。But this may result in the implementation of up to eight methods. You may go to the test code in <code>samples/TestCpp/Classes/TouchesTest</code> and review the code used in the Paddle.h and Paddle.cpp files for an example of <code>CCTargetedTouchDelegate</code> in action.</p><h4 id="行动：主循环"><a name="行动：主循环" href="#行动：主循环"></a>行动：主循环</h4><p><code>update</code>方法。</p><p>对速度施加一点摩擦力（0.98f）。如果没有发生碰撞，将在最后存储新位置：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void GameLayer::update (float dt) {
        CCPoint ballNextPosition = _ball-&amp;gt;getNextPosition();
        CCPoint ballVector = _ball-&amp;gt;getVector();
        ballVector = ccpMult(ballVector, 0.98f);
        ballNextPosition.x += ballVector.x;
        ballNextPosition.y += ballVector.y;
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> GameLayer::update (<span class="hljs-keyword">float</span> dt) {
        CCPoint ballNextPosition = _ball-&gt;getNextPosition();
        CCPoint ballVector = _ball-&gt;getVector();
        ballVector = ccpMult(ballVector, <span class="hljs-number">0.98f</span>);
        ballNextPosition.x += ballVector.x;
        ballNextPosition.y += ballVector.y;
</code></pre><p>接下来碰撞检测：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;        GameSprite * player;
        CCPoint playerNextPosition;
        CCPoint playerVector;

        float squared_radii = pow(_player1-&amp;gt;radius() + _ball-&amp;gt;radius(), 2);
        for (int p = 0; p &amp;lt; _players-&amp;gt;count(); p++) {
            player = (GameSprite *) _players-&amp;gt;objectAtIndex(p);
            playerNextPosition = player-&amp;gt;getNextPosition();
            playerVector = player-&amp;gt;getVector();
            float diffx = ballNextPosition.x - player-&amp;gt;getPositionX();
            float diffy = ballNextPosition.y - player-&amp;gt;getPositionY();
            float distance1 = pow(diffx, 2) + pow(diffy, 2);
            float distance2 = pow(_ball-&amp;gt;getPositionX() - playerNextPosition.x, 2)
                + pow(_ball-&amp;gt;getPositionY() - playerNextPosition.y, 2);
&lt;/code&gt;&lt;/pre&gt;">        GameSprite * player;
        CCPoint playerNextPosition;
        CCPoint playerVector;

        <span class="hljs-keyword">float</span> squared_radii = <span class="hljs-built_in">pow</span>(_player1-&gt;radius() + _ball-&gt;radius(), <span class="hljs-number">2</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>; p &lt; _players-&gt;count(); p++) {
            player = (GameSprite *) _players-&gt;objectAtIndex(p);
            playerNextPosition = player-&gt;getNextPosition();
            playerVector = player-&gt;getVector();
            <span class="hljs-keyword">float</span> diffx = ballNextPosition.x - player-&gt;getPositionX();
            <span class="hljs-keyword">float</span> diffy = ballNextPosition.y - player-&gt;getPositionY();
            <span class="hljs-keyword">float</span> distance1 = <span class="hljs-built_in">pow</span>(diffx, <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(diffy, <span class="hljs-number">2</span>);
            <span class="hljs-keyword">float</span> distance2 = <span class="hljs-built_in">pow</span>(_ball-&gt;getPositionX() - playerNextPosition.x, <span class="hljs-number">2</span>)
                + <span class="hljs-built_in">pow</span>(_ball-&gt;getPositionY() - playerNextPosition.y, <span class="hljs-number">2</span>);
</code></pre><p>既检查角色的当前位置，也检查下一个位置，防止球“穿过”角色。</p><p>当发生碰撞时，更加球的速度向量和球员的速度向量，计算球的下一个位置。并播放声效：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;            float mag_ball = pow(ballVector.x, 2) + pow(ballVector.y, 2);
            float mag_player = pow(playerVector.x, 2) + pow(playerVector.y, 2);
            float force = sqrt(mag_ball + mag_player);
            float angle = atan2(diffy, diffx);
            ballVector.x = force * cos(angle);
            ballVector.y = (force * sin(angle));
            ballNextPosition.x = playerNextPosition.x +
                (player-&amp;gt;radius() + _ball-&amp;gt;radius() + force) * cos(angle);
            ballNextPosition.y = playerNextPosition.y +
                (player-&amp;gt;radius() + _ball-&amp;gt;radius() + force) * sin(angle);
            SimpleAudioEngine::sharedEngine()-&amp;gt;playEffect(&quot;hit.wav&quot;);
        }
    }
&lt;/code&gt;&lt;/pre&gt;">            <span class="hljs-keyword">float</span> mag_ball = <span class="hljs-built_in">pow</span>(ballVector.x, <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(ballVector.y, <span class="hljs-number">2</span>);
            <span class="hljs-keyword">float</span> mag_player = <span class="hljs-built_in">pow</span>(playerVector.x, <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(playerVector.y, <span class="hljs-number">2</span>);
            <span class="hljs-keyword">float</span> force = <span class="hljs-built_in">sqrt</span>(mag_ball + mag_player);
            <span class="hljs-keyword">float</span> angle = <span class="hljs-built_in">atan2</span>(diffy, diffx);
            ballVector.x = force * <span class="hljs-built_in">cos</span>(angle);
            ballVector.y = (force * <span class="hljs-built_in">sin</span>(angle));
            ballNextPosition.x = playerNextPosition.x +
                (player-&gt;radius() + _ball-&gt;radius() + force) * <span class="hljs-built_in">cos</span>(angle);
            ballNextPosition.y = playerNextPosition.y +
                (player-&gt;radius() + _ball-&gt;radius() + force) * <span class="hljs-built_in">sin</span>(angle);
            SimpleAudioEngine::sharedEngine()-&gt;playEffect(<span class="hljs-string">"hit.wav"</span>);
        }
    }
</code></pre><p>下面检查球和屏幕边缘的碰撞。如果发生碰撞，将球反弹并播放音效：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    if (ballNextPosition.x &amp;lt; _ball-&amp;gt;radius()) {
        ballNextPosition.x = _ball-&amp;gt;radius();
        ballVector.x *= -0.8f;
        SimpleAudioEngine::sharedEngine()-&amp;gt;playEffect(&quot;hit.wav&quot;);
    }
    if (ballNextPosition.x &amp;gt; _screenSize.width - _ball-&amp;gt;radius()) {
        ballNextPosition.x = _screenSize.width - _ball-&amp;gt;radius();
        ballVector.x *= -0.8f;
        SimpleAudioEngine::sharedEngine()-&amp;gt;playEffect(&quot;hit.wav&quot;);
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">if</span> (ballNextPosition.x &lt; _ball-&gt;radius()) {
        ballNextPosition.x = _ball-&gt;radius();
        ballVector.x *= -<span class="hljs-number">0.8f</span>;
        SimpleAudioEngine::sharedEngine()-&gt;playEffect(<span class="hljs-string">"hit.wav"</span>);
    }
    <span class="hljs-keyword">if</span> (ballNextPosition.x &gt; _screenSize.width - _ball-&gt;radius()) {
        ballNextPosition.x = _screenSize.width - _ball-&gt;radius();
        ballVector.x *= -<span class="hljs-number">0.8f</span>;
        SimpleAudioEngine::sharedEngine()-&gt;playEffect(<span class="hljs-string">"hit.wav"</span>);
    }
</code></pre><p>如果球到达球场上下边，检查球是否进入了球门：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    if (ballNextPosition.y &amp;gt; _screenSize.height - _ball-&amp;gt;radius()) {
        if (_ball-&amp;gt;getPosition().x &amp;lt; _screenSize.width * 0.5f - GOAL_WIDTH * 0.5f
            || _ball-&amp;gt;getPosition().x &amp;gt; _screenSize.width * 0.5f + GOAL_WIDTH * 0.5f) {
            ballNextPosition.y = _screenSize.height - _ball-&amp;gt;radius();
            ballVector.y *= -0.8f;
            SimpleAudioEngine::sharedEngine()-&amp;gt;playEffect(&quot;hit.wav&quot;);
        }
    }
    if (ballNextPosition.y &amp;lt; _ball-&amp;gt;radius() ) {
        if (_ball-&amp;gt;getPosition().x &amp;lt; _screenSize.width * 0.5f - GOAL_WIDTH * 0.5f
            || _ball-&amp;gt;getPosition().x &amp;gt; _screenSize.width * 0.5f + GOAL_WIDTH * 0.5f) {
            ballNextPosition.y = _ball-&amp;gt;radius();
            ballVector.y *= -0.8f;
            SimpleAudioEngine::sharedEngine()-&amp;gt;playEffect(&quot;hit.wav&quot;);
        }
    }

    _ball-&amp;gt;setVector(ballVector);
    _ball-&amp;gt;setNextPosition(ballNextPosition);
    //check for goals!
    if (ballNextPosition.y &amp;lt; -_ball-&amp;gt;radius() * 2) {
        this-&amp;gt;playerScore(2);
    }
    if (ballNextPosition.y &amp;gt; _screenSize.height + _ball-&amp;gt;radius() * 2) {
        this-&amp;gt;playerScore(1);
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">if</span> (ballNextPosition.y &gt; _screenSize.height - _ball-&gt;radius()) {
        <span class="hljs-keyword">if</span> (_ball-&gt;getPosition().x &lt; _screenSize.width * <span class="hljs-number">0.5f</span> - GOAL_WIDTH * <span class="hljs-number">0.5f</span>
            || _ball-&gt;getPosition().x &gt; _screenSize.width * <span class="hljs-number">0.5f</span> + GOAL_WIDTH * <span class="hljs-number">0.5f</span>) {
            ballNextPosition.y = _screenSize.height - _ball-&gt;radius();
            ballVector.y *= -<span class="hljs-number">0.8f</span>;
            SimpleAudioEngine::sharedEngine()-&gt;playEffect(<span class="hljs-string">"hit.wav"</span>);
        }
    }
    <span class="hljs-keyword">if</span> (ballNextPosition.y &lt; _ball-&gt;radius() ) {
        <span class="hljs-keyword">if</span> (_ball-&gt;getPosition().x &lt; _screenSize.width * <span class="hljs-number">0.5f</span> - GOAL_WIDTH * <span class="hljs-number">0.5f</span>
            || _ball-&gt;getPosition().x &gt; _screenSize.width * <span class="hljs-number">0.5f</span> + GOAL_WIDTH * <span class="hljs-number">0.5f</span>) {
            ballNextPosition.y = _ball-&gt;radius();
            ballVector.y *= -<span class="hljs-number">0.8f</span>;
            SimpleAudioEngine::sharedEngine()-&gt;playEffect(<span class="hljs-string">"hit.wav"</span>);
        }
    }

    _ball-&gt;setVector(ballVector);
    _ball-&gt;setNextPosition(ballNextPosition);
    <span class="hljs-comment">//check for goals!</span>
    <span class="hljs-keyword">if</span> (ballNextPosition.y &lt; -_ball-&gt;radius() * <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">this</span>-&gt;playerScore(<span class="hljs-number">2</span>);
    }
    <span class="hljs-keyword">if</span> (ballNextPosition.y &gt; _screenSize.height + _ball-&gt;radius() * <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">this</span>-&gt;playerScore(<span class="hljs-number">1</span>);
    }
</code></pre><p>最后，更新所有对象的位置：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    _player1-&amp;gt;setPosition(_player1-&amp;gt;getNextPosition());
    _player2-&amp;gt;setPosition(_player2-&amp;gt;getNextPosition());
    _ball-&amp;gt;setPosition(_ball-&amp;gt;getNextPosition());
&lt;/code&gt;&lt;/pre&gt;">    _player1-&gt;setPosition(_player1-&gt;getNextPosition());
    _player2-&gt;setPosition(_player2-&gt;getNextPosition());
    _ball-&gt;setPosition(_ball-&gt;getNextPosition());
</code></pre><p>如果向做精确的碰撞检测，逻辑必定是一样的：position now, position next, collision checks, and adjustments to position next, if any collision has occurred.</p><h4 id="行动：更新分数"><a name="行动：更新分数" href="#行动：更新分数"></a>行动：更新分数</h4><p>播放音效并停止球的运动：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void GameLayer::playerScore (int player) {
        SimpleAudioEngine::sharedEngine()-&amp;gt;playEffect(&quot;score.wav&quot;);
        _ball-&amp;gt;setVector(ccp(0,0));
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> GameLayer::playerScore (<span class="hljs-keyword">int</span> player) {
        SimpleAudioEngine::sharedEngine()-&gt;playEffect(<span class="hljs-string">"score.wav"</span>);
        _ball-&gt;setVector(ccp(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));
</code></pre><p>Then we update the score for the scoring player, updating the score label in the process. And the ball moves to the court of the player against whom a point was just scored:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;        char score_buffer[10];
        if (player == 1) {
            _player1Score++;
            sprintf(score_buffer, &quot;%i&quot;, _player1Score);
            _player1ScoreLabel-&amp;gt;setString(score_buffer);
            _ball-&amp;gt;setNextPosition(ccp(_screenSize.width * 0.5,
                _screenSize.height * 0.5 + 2 * _ball-&amp;gt;radius()));
        } else {
            _player2Score++;
            sprintf(score_buffer, &quot;%i&quot;, _player2Score);
            _player2ScoreLabel-&amp;gt;setString(score_buffer);
            _ball-&amp;gt;setNextPosition(ccp(_screenSize.width * 0.5,
                _screenSize.height * 0.5 - 2 * _ball-&amp;gt;radius()));
        }
&lt;/code&gt;&lt;/pre&gt;">        <span class="hljs-keyword">char</span> score_buffer[<span class="hljs-number">10</span>];
        <span class="hljs-keyword">if</span> (player == <span class="hljs-number">1</span>) {
            _player1Score++;
            <span class="hljs-built_in">sprintf</span>(score_buffer, <span class="hljs-string">"%i"</span>, _player1Score);
            _player1ScoreLabel-&gt;setString(score_buffer);
            _ball-&gt;setNextPosition(ccp(_screenSize.width * <span class="hljs-number">0.5</span>,
                _screenSize.height * <span class="hljs-number">0.5</span> + <span class="hljs-number">2</span> * _ball-&gt;radius()));
        } <span class="hljs-keyword">else</span> {
            _player2Score++;
            <span class="hljs-built_in">sprintf</span>(score_buffer, <span class="hljs-string">"%i"</span>, _player2Score);
            _player2ScoreLabel-&gt;setString(score_buffer);
            _ball-&gt;setNextPosition(ccp(_screenSize.width * <span class="hljs-number">0.5</span>,
                _screenSize.height * <span class="hljs-number">0.5</span> - <span class="hljs-number">2</span> * _ball-&gt;radius()));
        }
</code></pre><p>The players are moved to their original position and their <code>_touch</code> properties are cleared:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;        _player1-&amp;gt;setPosition(ccp(_screenSize.width * 0.5,
            _player1-&amp;gt;radius() * 2));
        _player2-&amp;gt;setPosition(ccp(_screenSize.width * 0.5,
            _screenSize.height - _player1-&amp;gt;radius() * 2));
        _player1-&amp;gt;setTouch(NULL);
        _player2-&amp;gt;setTouch(NULL);
    }
&lt;/code&gt;&lt;/pre&gt;">        _player1-&gt;setPosition(ccp(_screenSize.width * <span class="hljs-number">0.5</span>,
            _player1-&gt;radius() * <span class="hljs-number">2</span>));
        _player2-&gt;setPosition(ccp(_screenSize.width * <span class="hljs-number">0.5</span>,
            _screenSize.height - _player1-&gt;radius() * <span class="hljs-number">2</span>));
        _player1-&gt;setTouch(NULL);
        _player2-&gt;setTouch(NULL);
    }
</code></pre><p>也可以使用<code>CCString</code>：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    CCString * score = CCString::createWithFormat(&quot;%i&quot;, _player1Score);
    _player1ScoreLabel-&amp;gt;setString(score-&amp;gt;getCString());
&lt;/code&gt;&lt;/pre&gt;">    CCString * score = CCString::createWithFormat(<span class="hljs-string">"%i"</span>, _player1Score);
    _player1ScoreLabel-&gt;setString(score-&gt;getCString());
</code></pre><h2 id="4.-sky-defense"><a name="4.-sky-defense" href="#4.-sky-defense"></a>4. Sky Defense</h2><p>介绍<strong>actions</strong>。如何只用action就能构建整个游戏：可以让角色移动、旋转、缩放等。如何利用多张图片和action让精灵动画。</p><p>本章内容：</p><ul>
<li>利用sprite sheets优化游戏开发</li>
<li>在游戏中使用bitmap fonts</li>
<li>How easy it is to implement and run CCActions</li>
<li>How to scale, rotate, swing, move, and fade out a sprite</li>
<li>使用多个.png做精灵动画</li>
<li>How to create a universal game with Cocos2d-x</li>
</ul><h3 id="the-game-–-sky-defense"><a name="the-game-–-sky-defense" href="#the-game-–-sky-defense"></a>The game – Sky Defense</h3><p>游戏剧情：Meet our stressed out city of… your name of choice here. It’s a beautiful day, when suddenly the sky begins to fall. There are meteors rushing towards the city and it is your job to keep it safe.</p><p>The player in this game can tap the screen to start growing a bomb. When the bomb is big enough to be activated, the player taps the screen again to detonate it. Any nearby meteor will explode into a million pieces. The bigger the bomb, the bigger the detonation and the more meteors can be taken out by it. But the bigger the bomb, the longer it takes to grow it.</p><p>But it’s not just bad news coming down. There are also health packs dropping from the sky and if you allow them to reach the ground, you’ll recover some of your energy.</p><h4 id="the-game-settings"><a name="the-game-settings" href="#the-game-settings"></a>The game settings</h4><p>This is a <strong>universal</strong> game. It is designed for the iPad retina screen and it will be scaled down to fit other screens. 游戏屏幕横屏。不支持多点触摸。</p><h4 id="the-start-project"><a name="the-start-project" href="#the-start-project"></a>The start project</h4><p>解压从<code>7341_04_START_PROJECT.zip</code>开始。Only this time, the <strong>Device Family</strong> is set to <strong>Universal</strong>. And in <code>RootViewController.mm</code>, the supported interface orientation is set to Landscape. 这次我们只需要一个类<code>GameLayer.cpp</code>, and you will find that the interface for this class already contains all of the information it needs.</p><h4 id="adding-screen-support-for-a-universal-app"><a name="adding-screen-support-for-a-universal-app" href="#adding-screen-support-for-a-universal-app"></a>Adding screen support for a universal app</h4><p>上一个工程只支持iPad屏。现在要支持更小的屏。打开<code>AppDelegate.cpp</code>，在<code>applicationDidFinishLaunching</code>中：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    CCSize screenSize = pEGLView-&amp;gt;getFrameSize();
    CCSize designSize = CCSize(2048, 1536);
    CCEGLView::sharedOpenGLView()-&amp;gt;setDesignResolutionSize(designSize.width,
        designSize.height, kResolutionExactFit);
    if (screenSize.height &amp;gt; 768) {
        CCFileUtils::sharedFileUtils()-&amp;gt;setResourceDirectory(&quot;ipadhd&quot;);
    } else if (screenSize.height &amp;gt; 320) {
        CCFileUtils::sharedFileUtils()-&amp;gt;setResourceDirectory(&quot;ipad&quot;);
    } else {
        CCFileUtils::sharedFileUtils()-&amp;gt;setResourceDirectory(&quot;iphone&quot;);
    }
    pDirector-&amp;gt;setContentScaleFactor(screenSize.height/designSize.height);
&lt;/code&gt;&lt;/pre&gt;">    CCSize screenSize = pEGLView-&gt;getFrameSize();
    CCSize designSize = CCSize(<span class="hljs-number">2048</span>, <span class="hljs-number">1536</span>);
    CCEGLView::sharedOpenGLView()-&gt;setDesignResolutionSize(designSize.width,
        designSize.height, kResolutionExactFit);
    <span class="hljs-keyword">if</span> (screenSize.height &gt; <span class="hljs-number">768</span>) {
        CCFileUtils::sharedFileUtils()-&gt;setResourceDirectory(<span class="hljs-string">"ipadhd"</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (screenSize.height &gt; <span class="hljs-number">320</span>) {
        CCFileUtils::sharedFileUtils()-&gt;setResourceDirectory(<span class="hljs-string">"ipad"</span>);
    } <span class="hljs-keyword">else</span> {
        CCFileUtils::sharedFileUtils()-&gt;setResourceDirectory(<span class="hljs-string">"iphone"</span>);
    }
    pDirector-&gt;setContentScaleFactor(screenSize.height/designSize.height);
</code></pre><p>最后设置了缩放因数。</p><h4 id="添加背景音乐"><a name="添加背景音乐" href="#添加背景音乐"></a>添加背景音乐</h4><p><code>AppDelegate.cpp</code>：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    SimpleAudioEngine::sharedEngine()-&amp;gt;preloadBackgroundMusic(file);
    // lower playback volume for effects
    SimpleAudioEngine::sharedEngine()-&amp;gt;setEffectsVolume(0.4f);
&lt;/code&gt;&lt;/pre&gt;">    SimpleAudioEngine::sharedEngine()-&gt;preloadBackgroundMusic(file);
    <span class="hljs-comment">// lower playback volume for effects</span>
    SimpleAudioEngine::sharedEngine()-&gt;setEffectsVolume(<span class="hljs-number">0.4f</span>);
</code></pre><p>背景音乐的音量通过<code>setBackgroundMusicVolume</code>设置。</p><h4 id="初始化游戏"><a name="初始化游戏" href="#初始化游戏"></a>初始化游戏</h4><p>回到<code>GameLayer.cpp</code>，查看<code>init</code>发现游戏初始化涉及三个方法：<code>createGameScreen</code>, <code>createPools</code>, <code>createActions</code>。</p><p>使用对象池，为了不必在主循环中再初始化精灵。</p><p>There is a <code>CCArray</code> called <code>_fallingObjects</code> also created here, and we start playing the background music, with the loop flag set to true:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    SimpleAudioEngine::sharedEngine()-&amp;gt;playBackgroundMusic(&quot;background.mp3&quot;, true);
&lt;/code&gt;&lt;/pre&gt;">    SimpleAudioEngine::sharedEngine()-&gt;playBackgroundMusic(<span class="hljs-string">"background.mp3"</span>, <span class="hljs-keyword">true</span>);
</code></pre><h3 id="使用sprite-sheets{{纹理贴图}}"><a name="使用sprite-sheets{{纹理贴图}}" href="#使用sprite-sheets{{纹理贴图}}"></a>使用sprite sheets{{纹理贴图}}</h3><p>精灵清单（sprite sheet）用于将多个图片组成成一张图片。当使用其中的一张图片给精灵贴图时，必须知道这张图片（矩形）在精灵清单的什么地方。精灵清单通常组织成两个文件：图片文件和数据文件。</p><p>I used TexturePacker to create these files for the game. You can find them inside the ipad, ipadhd, and iphone folders inside <strong>Resources</strong>. There is a <strong>sprite_sheet.png</strong> for the image and a <strong>sprite_sheet.plist</strong> that describes the individual frames inside the image.</p><p>下面是<strong>sprite_sheet.png</strong>：</p><p><img src="ch4-sprite-sheet.png" alt=""></p><p>精灵清单与一个特殊的<code>CCNode</code>类连用：<code>CCSpriteBatchNode</code>。当同一个节点内的多个精灵使用同一个图片文件时可以使用此类。With <code>CCSpriteBatchNode</code>, you can substantially reduce the number of calls during the rendering stage of your game, which will help when targeting less powerful systems, though <strong>not noticeably</strong> in the Apple device family.</p><p><code>CCSpriteBatchNode</code>像其他任何节点一样可以充当容器。利用z-order可以将<code>CCSprites</code>在batch node内分层排布。</p><h4 id="行动：创建一个`ccspritebatchnode`"><a name="行动：创建一个`ccspritebatchnode`" href="#行动：创建一个`ccspritebatchnode`"></a>行动：创建一个<code>CCSpriteBatchNode</code></h4><p>下面实现<code>GameLayer.cpp</code>的<code>createGameScreen</code>方法。Just below the lines that add the <code>bg</code> sprite, we instantiate our batch node:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void GameLayer::createGameScreen() {
        //add bg
        CCSprite * bg = CCSprite::create(&quot;bg.png&quot;);
        ...
        CCSpriteFrameCache::sharedSpriteFrameCache()-&amp;gt;
            addSpriteFramesWithFile(&quot;sprite_sheet.plist&quot;);
        _gameBatchNode = CCSpriteBatchNode::create(&quot;sprite_sheet.png&quot;);
        this-&amp;gt;addChild(_gameBatchNode);
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> GameLayer::createGameScreen() {
        <span class="hljs-comment">//add bg</span>
        CCSprite * bg = CCSprite::create(<span class="hljs-string">"bg.png"</span>);
        ...
        CCSpriteFrameCache::sharedSpriteFrameCache()-&gt;
            addSpriteFramesWithFile(<span class="hljs-string">"sprite_sheet.plist"</span>);
        _gameBatchNode = CCSpriteBatchNode::create(<span class="hljs-string">"sprite_sheet.png"</span>);
        <span class="hljs-keyword">this</span>-&gt;addChild(_gameBatchNode);
</code></pre><p>要利用精灵清单创建batch node，需要先加载帧信息：将<code>sprite_sheet.plist</code>加载到<code>CCSpriteFrameCache</code>。然后用<code>sprite_sheet.png</code>创建batch node。（背景图片不在贴图内，于是单独加载。）</p><p>创建<code>CCSprites</code>使用的帧名，在定义在<code>sprite_sheet.plist</code>。</p><p>接下来向<code>CCSpriteBatchNode</code>添加精灵。首先是city:<br>｛｛下面从清单中创建精灵时貌似只用到了帧，没有用到batch node。<br>难道通过帧创建的精灵只能添加到batch node？其此batch node必须通过清单的图片创建？｝｝</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    CCSprite * sprite;
    for (int i = 0; i &amp;lt; 2; i++) {
        sprite = CCSprite::createWithSpriteFrameName(&quot;city_dark.png&quot;);
        sprite-&amp;gt;setPosition(ccp(_screenSize.width * (0.25f + i * 0.5f),
            sprite-&amp;gt;boundingBox().size.height * 0.5f));
        _gameBatchNode-&amp;gt;addChild(sprite, kForeground);

        sprite = CCSprite::createWithSpriteFrameName(&quot;city_light.png&quot;);
        sprite-&amp;gt;setPosition(ccp(_screenSize.width * (0.25f + i * 0.5f),
            sprite-&amp;gt;boundingBox().size.height * 0.9f));
        _gameBatchNode-&amp;gt;addChild(sprite, kBackground);
    }
&lt;/code&gt;&lt;/pre&gt;">    CCSprite * sprite;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) {
        sprite = CCSprite::createWithSpriteFrameName(<span class="hljs-string">"city_dark.png"</span>);
        sprite-&gt;setPosition(ccp(_screenSize.width * (<span class="hljs-number">0.25f</span> + i * <span class="hljs-number">0.5f</span>),
            sprite-&gt;boundingBox().size.height * <span class="hljs-number">0.5f</span>));
        _gameBatchNode-&gt;addChild(sprite, kForeground);

        sprite = CCSprite::createWithSpriteFrameName(<span class="hljs-string">"city_light.png"</span>);
        sprite-&gt;setPosition(ccp(_screenSize.width * (<span class="hljs-number">0.25f</span> + i * <span class="hljs-number">0.5f</span>),
            sprite-&gt;boundingBox().size.height * <span class="hljs-number">0.9f</span>));
        _gameBatchNode-&gt;addChild(sprite, kBackground);
    }
</code></pre><p>然后是树：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    //add trees
    for (int i = 0; i &amp;lt; 3; i++) {
        sprite = CCSprite::createWithSpriteFrameName(&quot;trees.png&quot;);
        sprite-&amp;gt;setPosition(ccp(
            _screenSize.width * (0.2f + i * 0.3f),
            sprite-&amp;gt;boundingBox().size.height * 0.5f));
        _gameBatchNode-&amp;gt;addChild(sprite, kForeground);
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-comment">//add trees</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
        sprite = CCSprite::createWithSpriteFrameName(<span class="hljs-string">"trees.png"</span>);
        sprite-&gt;setPosition(ccp(
            _screenSize.width * (<span class="hljs-number">0.2f</span> + i * <span class="hljs-number">0.3f</span>),
            sprite-&gt;boundingBox().size.height * <span class="hljs-number">0.5f</span>));
        _gameBatchNode-&gt;addChild(sprite, kForeground);
    }
</code></pre><p>The screen so far is made up of two instances of city_dark.png tiling at the bottom of the screen, and two instances of city_light.png that are also tiling. One needs to appear on top of the other, and for that we use the enumerated values declared in <code>GameLayer.h</code>:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    enum {
        kBackground,
        kMiddleground,
        kForeground
    };
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">enum</span> {
        kBackground,
        kMiddleground,
        kForeground
    };
</code></pre><h3 id="bitmap字体"><a name="bitmap字体" href="#bitmap字体"></a>Bitmap字体</h3><p><code>CCLabelBMFont</code>用bitmap图像显式字母，而<code>CCLabelTTF</code>用的是true type font文件。</p><p>The bitmap image we are using here was created with the program <strong>GlyphDesigner</strong>, and in essence it works just as a sprite sheet does. 其实<code>CCLabelBMFont</code>是<code>CCSpriteBatchNode</code>的子类, so it behaves just like a batch node. You have images for all of the individual characters that you’ll need packed inside a PNG file (font.png), and then a data file (font.fnt) describing where each character is.</p><p><img src="ch4-bitmap-font.png" alt=""></p><p>The difference between <code>CCLabelBMFont</code> and a regular <code>CCSpriteBatchNode</code> is that the data file also feeds the <code>CCLabelBMFont</code> object information on how to “write” with this font. In other words, how to space out the characters and lines correctly. 创建<code>CCLabelBMFont</code>是需要的参数依次是：初始字符串值、数据文件名，标签对象的宽度。</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    _scoreDisplay = CCLabelBMFont::create(&quot;0&quot;, &quot;font.fnt&quot;, _screenSize.width * 0.3f);
&lt;/code&gt;&lt;/pre&gt;">    _scoreDisplay = CCLabelBMFont::create(<span class="hljs-string">"0"</span>, <span class="hljs-string">"font.fnt"</span>, _screenSize.width * <span class="hljs-number">0.3f</span>);
</code></pre><p>可以通过<code>setString</code>改变标签内容：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    _scoreDisplay-&amp;gt;setString(&quot;My new Label&quot;);
&lt;/code&gt;&lt;/pre&gt;">    _scoreDisplay-&gt;setString(<span class="hljs-string">"My new Label"</span>);
</code></pre><h4 id="行动：创建`cclabelbmfont`"><a name="行动：创建`cclabelbmfont`" href="#行动：创建`cclabelbmfont`"></a>行动：创建<code>CCLabelBMFont</code></h4><p>仍然在<code>createGameScreen</code>方法中：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    _scoreDisplay = CCLabelBMFont::create(&quot;0&quot;, &quot;font.fnt&quot;,
        _screenSize.width * 0.3f);
    _scoreDisplay-&amp;gt;setAnchorPoint(ccp(1, 0.5));
    _scoreDisplay-&amp;gt;setPosition(ccp(_screenSize.width * 0.8f,
        _screenSize.height * 0.94f));
    this-&amp;gt;addChild(_scoreDisplay);

    // And then add a label to display the energy level:
    _energyDisplay = CCLabelBMFont::create(&quot;100%&quot;, &quot;font.fnt&quot;,
        _screenSize.width * 0.1f, kCCTextAlignmentRight);
    _energyDisplay-&amp;gt;setPosition(ccp(_screenSize.width * 0.3f,
        _screenSize.height * 0.94f));
    this-&amp;gt;addChild(_energyDisplay);

    // _energyDisplaylabel后面的一个图标
    CCSprite * icon = CCSprite::createWithSpriteFrameName(&quot;health_icon.png&quot;);
    icon-&amp;gt;setPosition(ccp(_screenSize.width * 0.15f,
        _screenSize.height * 0.94f));
    _gameBatchNode-&amp;gt;addChild(icon, kBackground);
&lt;/code&gt;&lt;/pre&gt;">    _scoreDisplay = CCLabelBMFont::create(<span class="hljs-string">"0"</span>, <span class="hljs-string">"font.fnt"</span>,
        _screenSize.width * <span class="hljs-number">0.3f</span>);
    _scoreDisplay-&gt;setAnchorPoint(ccp(<span class="hljs-number">1</span>, <span class="hljs-number">0.5</span>));
    _scoreDisplay-&gt;setPosition(ccp(_screenSize.width * <span class="hljs-number">0.8f</span>,
        _screenSize.height * <span class="hljs-number">0.94f</span>));
    <span class="hljs-keyword">this</span>-&gt;addChild(_scoreDisplay);

    <span class="hljs-comment">// And then add a label to display the energy level:</span>
    _energyDisplay = CCLabelBMFont::create(<span class="hljs-string">"100%"</span>, <span class="hljs-string">"font.fnt"</span>,
        _screenSize.width * <span class="hljs-number">0.1f</span>, kCCTextAlignmentRight);
    _energyDisplay-&gt;setPosition(ccp(_screenSize.width * <span class="hljs-number">0.3f</span>,
        _screenSize.height * <span class="hljs-number">0.94f</span>));
    <span class="hljs-keyword">this</span>-&gt;addChild(_energyDisplay);

    <span class="hljs-comment">// _energyDisplaylabel后面的一个图标</span>
    CCSprite * icon = CCSprite::createWithSpriteFrameName(<span class="hljs-string">"health_icon.png"</span>);
    icon-&gt;setPosition(ccp(_screenSize.width * <span class="hljs-number">0.15f</span>,
        _screenSize.height * <span class="hljs-number">0.94f</span>));
    _gameBatchNode-&gt;addChild(icon, kBackground);
</code></pre><h4 id="行动：添加最终的屏幕精灵"><a name="行动：添加最终的屏幕精灵" href="#行动：添加最终的屏幕精灵"></a>行动：添加最终的屏幕精灵</h4><p>最后需要创建的精灵是云、炸弹和冲击波，及游戏的状态消息。</p><p>仍然在<code>createGameScreen</code>，添加云：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    CCSprite * cloud;
    _clouds = CCArray::createWithCapacity(4); // 用数组，为了将来移动云
    _clouds-&amp;gt;retain();
    float cloud_y;
    for (int i = 0; i &amp;lt; 4; i++) {
        cloud_y = i % 2 == 0 ? _screenSize.height * 0.4f : _screenSize.height * 0.5f;
        cloud = CCSprite::createWithSpriteFrameName(&quot;cloud.png&quot;);
        cloud-&amp;gt;setPosition(ccp (_screenSize.width * 0.1f + i * _screenSize.width * 0.3f, cloud_y));
        _gameBatchNode-&amp;gt;addChild(cloud, kBackground);
        _clouds-&amp;gt;addObject(cloud);
    }
&lt;/code&gt;&lt;/pre&gt;">    CCSprite * cloud;
    _clouds = CCArray::createWithCapacity(<span class="hljs-number">4</span>); <span class="hljs-comment">// 用数组，为了将来移动云</span>
    _clouds-&gt;retain();
    <span class="hljs-keyword">float</span> cloud_y;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) {
        cloud_y = i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? _screenSize.height * <span class="hljs-number">0.4f</span> : _screenSize.height * <span class="hljs-number">0.5f</span>;
        cloud = CCSprite::createWithSpriteFrameName(<span class="hljs-string">"cloud.png"</span>);
        cloud-&gt;setPosition(ccp (_screenSize.width * <span class="hljs-number">0.1f</span> + i * _screenSize.width * <span class="hljs-number">0.3f</span>, cloud_y));
        _gameBatchNode-&gt;addChild(cloud, kBackground);
        _clouds-&gt;addObject(cloud);
    }
</code></pre><p>创建<code>_bomb</code>精灵。用户按住屏幕时会变大：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    _bomb = CCSprite::createWithSpriteFrameName(&quot;bomb.png&quot;);
    _bomb-&amp;gt;getTexture()-&amp;gt;generateMipmap();
    _bomb-&amp;gt;setVisible(false);
    CCSize size = _bomb-&amp;gt;boundingBox().size;
    // add sparkle inside bomb sprite
    CCSprite * sparkle = CCSprite::createWithSpriteFrameName(&quot;sparkle.png&quot;);
    sparkle-&amp;gt;setPosition(ccp(size.width * 0.72f, size.height * 0.72f));
    // sparkle作为_bomb的孩子！而不是_gameBatchNode
    _bomb-&amp;gt;addChild(sparkle, kMiddleground, kSpriteSparkle);

    //add halo inside bomb sprite
    CCSprite * halo = CCSprite::createWithSpriteFrameName(&quot;halo.png&quot;);
    halo-&amp;gt;setPosition(ccp(size.width * 0.4f, size.height * 0.4f));
    _bomb-&amp;gt;addChild(halo, kMiddleground, kSpriteHalo);

    _gameBatchNode-&amp;gt;addChild(_bomb, kForeground);
&lt;/code&gt;&lt;/pre&gt;">    _bomb = CCSprite::createWithSpriteFrameName(<span class="hljs-string">"bomb.png"</span>);
    _bomb-&gt;getTexture()-&gt;generateMipmap();
    _bomb-&gt;setVisible(<span class="hljs-keyword">false</span>);
    CCSize size = _bomb-&gt;boundingBox().size;
    <span class="hljs-comment">// add sparkle inside bomb sprite</span>
    CCSprite * sparkle = CCSprite::createWithSpriteFrameName(<span class="hljs-string">"sparkle.png"</span>);
    sparkle-&gt;setPosition(ccp(size.width * <span class="hljs-number">0.72f</span>, size.height * <span class="hljs-number">0.72f</span>));
    <span class="hljs-comment">// sparkle作为_bomb的孩子！而不是_gameBatchNode</span>
    _bomb-&gt;addChild(sparkle, kMiddleground, kSpriteSparkle);

    <span class="hljs-comment">//add halo inside bomb sprite</span>
    CCSprite * halo = CCSprite::createWithSpriteFrameName(<span class="hljs-string">"halo.png"</span>);
    halo-&gt;setPosition(ccp(size.width * <span class="hljs-number">0.4f</span>, size.height * <span class="hljs-number">0.4f</span>));
    _bomb-&gt;addChild(halo, kMiddleground, kSpriteHalo);

    _gameBatchNode-&gt;addChild(_bomb, kForeground);
</code></pre><p><code>_shockwave</code>精灵，在<code>_bomb</code>消失后出现：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    _shockWave = CCSprite::createWithSpriteFrameName(&quot;shockwave.png&quot;);
    _shockWave-&amp;gt;getTexture()-&amp;gt;generateMipmap();
    _shockWave-&amp;gt;setVisible(false);
    _gameBatchNode-&amp;gt;addChild(_shockWave);
&lt;/code&gt;&lt;/pre&gt;">    _shockWave = CCSprite::createWithSpriteFrameName(<span class="hljs-string">"shockwave.png"</span>);
    _shockWave-&gt;getTexture()-&gt;generateMipmap();
    _shockWave-&gt;setVisible(<span class="hljs-keyword">false</span>);
    _gameBatchNode-&gt;addChild(_shockWave);
</code></pre><p>最后，添加两条消息，分别用于游戏开始和结束状态：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    _introMessage = CCSprite::createWithSpriteFrameName(&quot;logo.png&quot;);
    _introMessage-&amp;gt;setPosition(ccp(_screenSize.width * 0.5f,
        _screenSize.height * 0.6f));
    _introMessage-&amp;gt;setVisible(true);
    this-&amp;gt;addChild(_introMessage, kForeground);

    _gameOverMessage = CCSprite::createWithSpriteFrameName(&quot;gameover.png&quot;);
    _gameOverMessage-&amp;gt;setPosition(ccp(_screenSize.width * 0.5f,
        _screenSize.height * 0.65f));
    _gameOverMessage-&amp;gt;setVisible(false);
    this-&amp;gt;addChild(_gameOverMessage, kForeground);
&lt;/code&gt;&lt;/pre&gt;">    _introMessage = CCSprite::createWithSpriteFrameName(<span class="hljs-string">"logo.png"</span>);
    _introMessage-&gt;setPosition(ccp(_screenSize.width * <span class="hljs-number">0.5f</span>,
        _screenSize.height * <span class="hljs-number">0.6f</span>));
    _introMessage-&gt;setVisible(<span class="hljs-keyword">true</span>);
    <span class="hljs-keyword">this</span>-&gt;addChild(_introMessage, kForeground);

    _gameOverMessage = CCSprite::createWithSpriteFrameName(<span class="hljs-string">"gameover.png"</span>);
    _gameOverMessage-&gt;setPosition(ccp(_screenSize.width * <span class="hljs-number">0.5f</span>,
        _screenSize.height * <span class="hljs-number">0.65f</span>));
    _gameOverMessage-&gt;setVisible(<span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">this</span>-&gt;addChild(_gameOverMessage, kForeground);
</code></pre><p><code>_bomb-&gt;getTexture()-&gt;generateMipmap();</code> With this, we are telling the framework to create antialiased copies of this texture in diminishing sizes (mipmaps), since we are going to scale it down later. This is optional of course, as sprites can be resized without first generating mipmaps, but if you notice a loss of quality in the scaled sprites, you can fix it by creating mipmaps for their texture.</p><blockquote>
<p>OpenGL的纹理大小必须是POT (power of two: 2, 4, 8, 16, and so on)。若不是Cocos2d-x将做两件事情：在内存中调整纹理大小，添加透明像素直到达到POT。或者，可能在某个<code>Assert</code>处停止执行。With textures used for mipmaps the framework will stop execution for non-POT textures.</p>
</blockquote><p>sparkle和halo是<code>_bomb</code>的孩子。当炸弹变大时，它的孩子也会跟着变大。</p><p><code>addChild</code>的第三个参数是一个整数标签：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    bomb-&amp;gt;addChild(halo, kMiddleground, kSpriteHalo);
&lt;/code&gt;&lt;/pre&gt;">    bomb-&gt;addChild(halo, kMiddleground, kSpriteHalo);
</code></pre><p>该标签来自<code>GameLayer.h</code>中的另一个枚举。利用此标签，可以从精灵中取到它的孩子：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    CCSprite * halo = (CCSprite *) bomb-&amp;gt;getChildByTag(kSpriteHalo);
&lt;/code&gt;&lt;/pre&gt;">    CCSprite * halo = (CCSprite *) bomb-&gt;getChildByTag(kSpriteHalo);
</code></pre><p><img src="ch4-demo-1.png" alt=""></p><h4 id="行动：创建对象池"><a name="行动：创建对象池" href="#行动：创建对象池"></a>行动：创建对象池</h4><p>池只是一个对象数组。在<code>createPools</code>方法：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void GameLayer::createPools() {
        CCSprite * sprite;
        int i;
        // 流星池
        _meteorPool = CCArray::createWithCapacity(50);
        _meteorPool-&amp;gt;retain();
        _meteorPoolIndex = 0;
        for (i = 0; i &amp;lt; 50; i++) {
            sprite = CCSprite::createWithSpriteFrameName(&quot;meteor.png&quot;);
            sprite-&amp;gt;setVisible(false);
            // 在节点关系上仍属于_gameBatchNode
            _gameBatchNode-&amp;gt;addChild(sprite, kMiddleground, kSpriteMeteor);
            _meteorPool-&amp;gt;addObject(sprite);
        }

        // 医疗包
        _healthPool = CCArray::createWithCapacity(20);
        _healthPool-&amp;gt;retain();
        _healthPoolIndex = 0;
        for (i = 0; i &amp;lt; 20; i++) {
            sprite = CCSprite::createWithSpriteFrameName(&quot;health.png&quot;);
            sprite-&amp;gt;setVisible(false);
            sprite-&amp;gt;setAnchorPoint(ccp(0.5f, 0.8f));
            _gameBatchNode-&amp;gt;addChild(sprite, kMiddleground, kSpriteHealth);
            _healthPool-&amp;gt;addObject(sprite);
        }
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> GameLayer::createPools() {
        CCSprite * sprite;
        <span class="hljs-keyword">int</span> i;
        <span class="hljs-comment">// 流星池</span>
        _meteorPool = CCArray::createWithCapacity(<span class="hljs-number">50</span>);
        _meteorPool-&gt;retain();
        _meteorPoolIndex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) {
            sprite = CCSprite::createWithSpriteFrameName(<span class="hljs-string">"meteor.png"</span>);
            sprite-&gt;setVisible(<span class="hljs-keyword">false</span>);
            <span class="hljs-comment">// 在节点关系上仍属于_gameBatchNode</span>
            _gameBatchNode-&gt;addChild(sprite, kMiddleground, kSpriteMeteor);
            _meteorPool-&gt;addObject(sprite);
        }

        <span class="hljs-comment">// 医疗包</span>
        _healthPool = CCArray::createWithCapacity(<span class="hljs-number">20</span>);
        _healthPool-&gt;retain();
        _healthPoolIndex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) {
            sprite = CCSprite::createWithSpriteFrameName(<span class="hljs-string">"health.png"</span>);
            sprite-&gt;setVisible(<span class="hljs-keyword">false</span>);
            sprite-&gt;setAnchorPoint(ccp(<span class="hljs-number">0.5f</span>, <span class="hljs-number">0.8f</span>));
            _gameBatchNode-&gt;addChild(sprite, kMiddleground, kSpriteHealth);
            _healthPool-&gt;addObject(sprite);
        }
    }
</code></pre><p>We’ll use the corresponding pool index to retrieve objects from the arrays as the game progresses.</p><h3 id="ccactions"><a name="ccactions" href="#ccactions"></a>CCActions</h3><p><code>CCNode</code>存储着节点的位置、缩放、旋转、可见性、透明度信息。可以通过<code>CCAction</code>类改变这些值，即产生动画。Actions一般通过静态方法create创建。第一个参数一般是action的时长。例如：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    CCFadeOut *fadeout = CCFadeOut::create(1.0f);
&lt;/code&gt;&lt;/pre&gt;">    CCFadeOut *fadeout = CCFadeOut::create(<span class="hljs-number">1.0f</span>);
</code></pre><p><code>1.0f</code>表示1秒。令节点运行此Action：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    mySprite-&amp;gt;runAction(fadeout);
&lt;/code&gt;&lt;/pre&gt;">    mySprite-&gt;runAction(fadeout);
</code></pre><p>还可以创建action序列（<code>CCSequence</code>）；or you can apply easing effects (CCEaseIn, CCEaseOut, and so on) to your actions. 可以重复action数次（<code>CCRepeat</code>）甚至永远（<code>CCRepeatForever</code>）；可以指定一个回调函数，在Action完成后执行。</p><h4 id="行动：创建actions"><a name="行动：创建actions" href="#行动：创建actions"></a>行动：创建Actions</h4><p>在<code>createActions</code>方法中，实例化在游戏中反复使用的actions。</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void GameLayer::createActions() {
        // 医药包下落时的摆动效果
        CCFiniteTimeAction* easeSwing = CCSequence::create(
            CCEaseInOut::create(CCRotateTo::create(1.2f, -10), 2),
            CCEaseInOut::create(CCRotateTo::create(1.2f, 10), 2),
            NULL);
        _swingHealth = CCRepeatForever::create((CCActionInterval*) easeSwing);
        _swingHealth-&amp;gt;retain();

        // 爆炸波淡出，完后调用函数
        _shockwaveSequence = CCSequence::create(
            CCFadeOut::create(1.0f),
            CCCallFunc::create(this, callfunc_selector(GameLayer::shockwaveDone)),
            NULL);
        _shockwaveSequence-&amp;gt;retain();

        // 让炸弹增大
        _growBomb = CCScaleTo::create(6.0f, 1.0);
        _growBomb-&amp;gt;retain();

        // action to rotate sprites
        CCActionInterval* rotate = CCRotateBy::create(0.5f , -90);
        _rotateSprite = CCRepeatForever::create( rotate );
        _rotateSprite-&amp;gt;retain();
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> GameLayer::createActions() {
        <span class="hljs-comment">// 医药包下落时的摆动效果</span>
        CCFiniteTimeAction* easeSwing = CCSequence::create(
            CCEaseInOut::create(CCRotateTo::create(<span class="hljs-number">1.2f</span>, -<span class="hljs-number">10</span>), <span class="hljs-number">2</span>),
            CCEaseInOut::create(CCRotateTo::create(<span class="hljs-number">1.2f</span>, <span class="hljs-number">10</span>), <span class="hljs-number">2</span>),
            NULL);
        _swingHealth = CCRepeatForever::create((CCActionInterval*) easeSwing);
        _swingHealth-&gt;retain();

        <span class="hljs-comment">// 爆炸波淡出，完后调用函数</span>
        _shockwaveSequence = CCSequence::create(
            CCFadeOut::create(<span class="hljs-number">1.0f</span>),
            CCCallFunc::create(<span class="hljs-keyword">this</span>, callfunc_selector(GameLayer::shockwaveDone)),
            NULL);
        _shockwaveSequence-&gt;retain();

        <span class="hljs-comment">// 让炸弹增大</span>
        _growBomb = CCScaleTo::create(<span class="hljs-number">6.0f</span>, <span class="hljs-number">1.0</span>);
        _growBomb-&gt;retain();

        <span class="hljs-comment">// action to rotate sprites</span>
        CCActionInterval* rotate = CCRotateBy::create(<span class="hljs-number">0.5f</span> , -<span class="hljs-number">90</span>);
        _rotateSprite = CCRepeatForever::create( rotate );
        _rotateSprite-&gt;retain();
</code></pre><h3 id="精灵动画"><a name="精灵动画" href="#精灵动画"></a>精灵动画</h3><p>动画仅是另一种形式的<code>CCAction</code>——改变的是<code>CCSprite</code>使用的纹理。动画action(<code>CCAnimate</code>)使用<code>CCAnimation</code>对象。<code>CCAnimation</code>包含动画所需的所有纹理。纹理（帧）是<code>CCSpriteFrame</code>对象，从<code>CCSpriteFrameCache</code>获取，后者包含<code>sprite_sheet.plist</code>中的信息。</p><h4 id="创建动画"><a name="创建动画" href="#创建动画"></a>创建动画</h4><p>仍在<code>createActions</code>方法。首先是流星到达城市时的爆炸。首先将帧加载到<code>CCAnimation</code>对象：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;        CCAnimation* animation;
        CCSpriteFrame * frame;
        //create CCAnimation object
        animation = CCAnimation::create();
        CCString * name;
        for(int i = 1; i &amp;lt;= 10; i++) {
            name = CCString::createWithFormat(&quot;boom%i.png&quot;, i);
            frame = CCSpriteFrameCache::sharedSpriteFrameCache()
                -&amp;gt;spriteFrameByName(name-&amp;gt;getCString());
            animation-&amp;gt;addSpriteFrame(frame);
        }
&lt;/code&gt;&lt;/pre&gt;">        CCAnimation* animation;
        CCSpriteFrame * frame;
        <span class="hljs-comment">//create CCAnimation object</span>
        animation = CCAnimation::create();
        CCString * name;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) {
            name = CCString::createWithFormat(<span class="hljs-string">"boom%i.png"</span>, i);
            frame = CCSpriteFrameCache::sharedSpriteFrameCache()
                -&gt;spriteFrameByName(name-&gt;getCString());
            animation-&gt;addSpriteFrame(frame);
        }
</code></pre><p>利用<code>CCAnimation</code>创建<code>CCAnimate</code>：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;        animation-&amp;gt;setDelayPerUnit(1 / 10.0f);
        animation-&amp;gt;setRestoreOriginalFrame(true);
        _groundHit = CCSequence::create(
            CCMoveBy::create(0, ccp(0, _screenSize.height * 0.12f)),
            CCAnimate::create(animation),
            CCCallFuncN::create(this, callfuncN_selector(GameLayer::animationDone)),
            NULL);
        _groundHit-&amp;gt;retain();
&lt;/code&gt;&lt;/pre&gt;">        animation-&gt;setDelayPerUnit(<span class="hljs-number">1</span> / <span class="hljs-number">10.0f</span>);
        animation-&gt;setRestoreOriginalFrame(<span class="hljs-keyword">true</span>);
        _groundHit = CCSequence::create(
            CCMoveBy::create(<span class="hljs-number">0</span>, ccp(<span class="hljs-number">0</span>, _screenSize.height * <span class="hljs-number">0.12f</span>)),
            CCAnimate::create(animation),
            CCCallFuncN::create(<span class="hljs-keyword">this</span>, callfuncN_selector(GameLayer::animationDone)),
            NULL);
        _groundHit-&gt;retain();
</code></pre><p>The same steps are repeated to create the other explosion animation, which is used when the player hits a meteor or a health pack.</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;        animation = CCAnimation::create();
        for(int i = 1; i &amp;lt;= 7; i++) {
            name = CCString::createWithFormat(&quot;explosion_small%i.png&quot;, i);
            frame = CCSpriteFrameCache::sharedSpriteFrameCache()
                -&amp;gt;spriteFrameByName(name-&amp;gt;getCString());
            animation-&amp;gt;addSpriteFrame(frame);
        }
        animation-&amp;gt;setDelayPerUnit(0.5 / 7.0f);
        animation-&amp;gt;setRestoreOriginalFrame(true);
        _explosion = CCSequence::create(
            CCAnimate::create(animation),
            CCCallFuncN::create(this, callfuncN_selector
            (GameLayer::animationDone)),
            NULL);
        _explosion-&amp;gt;retain();
&lt;/code&gt;&lt;/pre&gt;">        animation = CCAnimation::create();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">7</span>; i++) {
            name = CCString::createWithFormat(<span class="hljs-string">"explosion_small%i.png"</span>, i);
            frame = CCSpriteFrameCache::sharedSpriteFrameCache()
                -&gt;spriteFrameByName(name-&gt;getCString());
            animation-&gt;addSpriteFrame(frame);
        }
        animation-&gt;setDelayPerUnit(<span class="hljs-number">0.5</span> / <span class="hljs-number">7.0f</span>);
        animation-&gt;setRestoreOriginalFrame(<span class="hljs-keyword">true</span>);
        _explosion = CCSequence::create(
            CCAnimate::create(animation),
            CCCallFuncN::create(<span class="hljs-keyword">this</span>, callfuncN_selector
            (GameLayer::animationDone)),
            NULL);
        _explosion-&gt;retain();
</code></pre><p>如果<code>setRestoreOriginalFrame</code>设为<code>true</code>，则在动画完成后，精灵将回到初始状态。</p><p>下面是<code>animationDone</code>回调，它的作用是让精灵消失｛｛pSender为什么能指向期望的精灵｝｝：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void GameLayer::animationDone (CCNode* pSender) {
        pSender-&amp;gt;setVisible(false);
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> GameLayer::animationDone (CCNode* pSender) {
        pSender-&gt;setVisible(<span class="hljs-keyword">false</span>);
    }
</code></pre><h3 id="令游戏运转"><a name="令游戏运转" href="#令游戏运转"></a>令游戏运转</h3><p>We will use a system of countdowns to add new meteors and new health packs, as well as a countdown that will incrementally make the game harder to play.</p><p>触摸后玩家开始游戏。如果游戏未运行，也防止炸弹并让它们爆炸。爆炸产生冲击波。</p><p>在<code>update</code>中，检查<code>_shockwave</code>和下落对象的碰撞。Cocos2d-x will take care of all of the rest through our created actions and callbacks!</p><h4 id="行动：处理触摸"><a name="行动：处理触摸" href="#行动：处理触摸"></a>行动：处理触摸</h4><p>实现<code>ccTouchesBegan</code>方法，处理两个状态：进入和游戏结束。</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void GameLayer::ccTouchesBegan(CCSet* pTouches, CCEvent* event){
        //if game not running, we are seeing either intro or gameover
        if (!_running) {
            //if intro, hide intro message
            if (_introMessage-&amp;gt;isVisible()) {
                _introMessage-&amp;gt;setVisible(false);
            //if game over, hide game over message
            } else if (_gameOverMessage-&amp;gt;isVisible()) {
                SimpleAudioEngine::sharedEngine()-&amp;gt;stopAllEffects();
                _gameOverMessage-&amp;gt;setVisible(false);
            }
            this-&amp;gt;resetGame();
            return;
        }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> GameLayer::ccTouchesBegan(CCSet* pTouches, CCEvent* event){
        <span class="hljs-comment">//if game not running, we are seeing either intro or gameover</span>
        <span class="hljs-keyword">if</span> (!_running) {
            <span class="hljs-comment">//if intro, hide intro message</span>
            <span class="hljs-keyword">if</span> (_introMessage-&gt;isVisible()) {
                _introMessage-&gt;setVisible(<span class="hljs-keyword">false</span>);
            <span class="hljs-comment">//if game over, hide game over message</span>
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_gameOverMessage-&gt;isVisible()) {
                SimpleAudioEngine::sharedEngine()-&gt;stopAllEffects();
                _gameOverMessage-&gt;setVisible(<span class="hljs-keyword">false</span>);
            }
            <span class="hljs-keyword">this</span>-&gt;resetGame();
            <span class="hljs-keyword">return</span>;
        }
</code></pre><p>接下来处理触摸。这里只需要处理单点，因此调用<code>-&gt;anyObject()</code>：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    CCTouch *touch = (CCTouch *)pTouches-&amp;gt;anyObject();
    if (touch) {
        //if bomb already growing...
        if (_bomb-&amp;gt;isVisible()) {
            //stop all actions on bomb, halo and sparkle
            _bomb-&amp;gt;stopAllActions();
            CCSprite *child;
            child = (CCSprite *) _bomb-&amp;gt;getChildByTag(kSpriteHalo);
            child-&amp;gt;stopAllActions();
            child = (CCSprite *) _bomb-&amp;gt;getChildByTag(kSpriteSparkle);
            child-&amp;gt;stopAllActions();
            // 如果炸弹足够大，则创建冲击波
            if (_bomb-&amp;gt;getScale() &amp;gt; 0.3f) {
                _shockWave-&amp;gt;setScale(0.1f);
                _shockWave-&amp;gt;setPosition(_bomb-&amp;gt;getPosition());
                _shockWave-&amp;gt;setVisible(true);
                _shockWave-&amp;gt;runAction(CCScaleTo::create(0.5f,
                    _bomb-&amp;gt;getScale() * 2.0f));
                _shockWave-&amp;gt;runAction((CCFiniteTimeAction*)_shockwaveSequence-&amp;gt;copy()-&amp;gt;autorelease());
                SimpleAudioEngine::sharedEngine()-&amp;gt;playEffect(&quot;bombRelease.wav&quot;);
            } else {
                // 炸弹不够大
                SimpleAudioEngine::sharedEngine()-&amp;gt;playEffect(&quot;bombFail.wav&quot;);
            }
            _bomb-&amp;gt;setVisible(false);
            // reset hits with shockwave, so we can count combo hits
            _shockwaveHits = 0;
        } else { //if no bomb currently on screen, create one
            CCPoint tap = touch-&amp;gt;getLocation();
            _bomb-&amp;gt;stopAllActions();
            _bomb-&amp;gt;setScale(0.1f);
            _bomb-&amp;gt;setPosition(tap);
            _bomb-&amp;gt;setVisible(true);
            _bomb-&amp;gt;setOpacity(50);
            _bomb-&amp;gt;runAction((CCAction *) _growBomb-&amp;gt;copy()-&amp;gt;autorelease());
            CCSprite * child;
            child = (CCSprite *) _bomb-&amp;gt;getChildByTag(kSpriteHalo);
            child-&amp;gt;runAction((CCAction *) _rotateSprite-&amp;gt;copy()-&amp;gt;autorelease());
            child = (CCSprite *) _bomb-&amp;gt;getChildByTag(kSpriteSparkle);
            child-&amp;gt;runAction((CCAction *) _rotateSprite-&amp;gt;copy()-&amp;gt;autorelease());
         }
    }
&lt;/code&gt;&lt;/pre&gt;">    CCTouch *touch = (CCTouch *)pTouches-&gt;anyObject();
    <span class="hljs-keyword">if</span> (touch) {
        <span class="hljs-comment">//if bomb already growing...</span>
        <span class="hljs-keyword">if</span> (_bomb-&gt;isVisible()) {
            <span class="hljs-comment">//stop all actions on bomb, halo and sparkle</span>
            _bomb-&gt;stopAllActions();
            CCSprite *child;
            child = (CCSprite *) _bomb-&gt;getChildByTag(kSpriteHalo);
            child-&gt;stopAllActions();
            child = (CCSprite *) _bomb-&gt;getChildByTag(kSpriteSparkle);
            child-&gt;stopAllActions();
            <span class="hljs-comment">// 如果炸弹足够大，则创建冲击波</span>
            <span class="hljs-keyword">if</span> (_bomb-&gt;getScale() &gt; <span class="hljs-number">0.3f</span>) {
                _shockWave-&gt;setScale(<span class="hljs-number">0.1f</span>);
                _shockWave-&gt;setPosition(_bomb-&gt;getPosition());
                _shockWave-&gt;setVisible(<span class="hljs-keyword">true</span>);
                _shockWave-&gt;runAction(CCScaleTo::create(<span class="hljs-number">0.5f</span>,
                    _bomb-&gt;getScale() * <span class="hljs-number">2.0f</span>));
                _shockWave-&gt;runAction((CCFiniteTimeAction*)_shockwaveSequence-&gt;copy()-&gt;autorelease());
                SimpleAudioEngine::sharedEngine()-&gt;playEffect(<span class="hljs-string">"bombRelease.wav"</span>);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">// 炸弹不够大</span>
                SimpleAudioEngine::sharedEngine()-&gt;playEffect(<span class="hljs-string">"bombFail.wav"</span>);
            }
            _bomb-&gt;setVisible(<span class="hljs-keyword">false</span>);
            <span class="hljs-comment">// reset hits with shockwave, so we can count combo hits</span>
            _shockwaveHits = <span class="hljs-number">0</span>;
        } <span class="hljs-keyword">else</span> { <span class="hljs-comment">//if no bomb currently on screen, create one</span>
            CCPoint tap = touch-&gt;getLocation();
            _bomb-&gt;stopAllActions();
            _bomb-&gt;setScale(<span class="hljs-number">0.1f</span>);
            _bomb-&gt;setPosition(tap);
            _bomb-&gt;setVisible(<span class="hljs-keyword">true</span>);
            _bomb-&gt;setOpacity(<span class="hljs-number">50</span>);
            _bomb-&gt;runAction((CCAction *) _growBomb-&gt;copy()-&gt;autorelease());
            CCSprite * child;
            child = (CCSprite *) _bomb-&gt;getChildByTag(kSpriteHalo);
            child-&gt;runAction((CCAction *) _rotateSprite-&gt;copy()-&gt;autorelease());
            child = (CCSprite *) _bomb-&gt;getChildByTag(kSpriteSparkle);
            child-&gt;runAction((CCAction *) _rotateSprite-&gt;copy()-&gt;autorelease());
         }
    }
</code></pre><h4 id="行动：开始和重启游戏"><a name="行动：开始和重启游戏" href="#行动：开始和重启游戏"></a>行动：开始和重启游戏</h4><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void GameLayer::resetGame(void) {
        _score = 0;
        _energy = 100;
        //reset timers and &quot;speeds&quot;
        _meteorInterval = 2.5;
        _meteorTimer = _meteorInterval * 0.99f;
        _meteorSpeed = 10;//in seconds to reach ground
        _healthInterval = 20;
        _healthTimer = 0;
        _healthSpeed = 15;//in seconds to reach ground
        _difficultyInterval = 60;
        _difficultyTimer = 0;
        _running = true;
        //reset labels
        CCString * value = CCString::createWithFormat(&quot;%i%s&quot;, _energy, &quot;%&quot;);
        _energyDisplay-&amp;gt;setString(value-&amp;gt;getCString());
        value = CCString::createWithFormat(&quot;%i&quot;, _score);
        _scoreDisplay-&amp;gt;setString(value-&amp;gt;getCString());
    }

    void GameLayer::stopGame() {
        _running = false;
        //stop all actions currently running
        int count = _fallingObjects-&amp;gt;count();
        CCSprite * sprite;
        for (int i = count-1; i &amp;gt;= 0; i--) {
            sprite = (CCSprite *) _fallingObjects-&amp;gt;objectAtIndex(i);
            sprite-&amp;gt;stopAllActions();
            sprite-&amp;gt;setVisible(false);
            _fallingObjects-&amp;gt;removeObjectAtIndex(i);
        }
        if (_bomb-&amp;gt;isVisible()) {
            _bomb-&amp;gt;stopAllActions();
            _bomb-&amp;gt;setVisible(false);
            CCSprite * child;
            child = (CCSprite *) _bomb-&amp;gt;getChildByTag(kSpriteHalo);
            child-&amp;gt;stopAllActions();
            child = (CCSprite *) _bomb-&amp;gt;getChildByTag(kSpriteSparkle);
            child-&amp;gt;stopAllActions();
        }
        if (_shockWave-&amp;gt;isVisible()) {
            _shockWave-&amp;gt;stopAllActions();
            _shockWave-&amp;gt;setVisible(false);
        }
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> GameLayer::resetGame(<span class="hljs-keyword">void</span>) {
        _score = <span class="hljs-number">0</span>;
        _energy = <span class="hljs-number">100</span>;
        <span class="hljs-comment">//reset timers and "speeds"</span>
        _meteorInterval = <span class="hljs-number">2.5</span>;
        _meteorTimer = _meteorInterval * <span class="hljs-number">0.99f</span>;
        _meteorSpeed = <span class="hljs-number">10</span>;<span class="hljs-comment">//in seconds to reach ground</span>
        _healthInterval = <span class="hljs-number">20</span>;
        _healthTimer = <span class="hljs-number">0</span>;
        _healthSpeed = <span class="hljs-number">15</span>;<span class="hljs-comment">//in seconds to reach ground</span>
        _difficultyInterval = <span class="hljs-number">60</span>;
        _difficultyTimer = <span class="hljs-number">0</span>;
        _running = <span class="hljs-keyword">true</span>;
        <span class="hljs-comment">//reset labels</span>
        CCString * value = CCString::createWithFormat(<span class="hljs-string">"%i%s"</span>, _energy, <span class="hljs-string">"%"</span>);
        _energyDisplay-&gt;setString(value-&gt;getCString());
        value = CCString::createWithFormat(<span class="hljs-string">"%i"</span>, _score);
        _scoreDisplay-&gt;setString(value-&gt;getCString());
    }

    <span class="hljs-keyword">void</span> GameLayer::stopGame() {
        _running = <span class="hljs-keyword">false</span>;
        <span class="hljs-comment">//stop all actions currently running</span>
        <span class="hljs-keyword">int</span> count = _fallingObjects-&gt;count();
        CCSprite * sprite;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = count-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
            sprite = (CCSprite *) _fallingObjects-&gt;objectAtIndex(i);
            sprite-&gt;stopAllActions();
            sprite-&gt;setVisible(<span class="hljs-keyword">false</span>);
            _fallingObjects-&gt;removeObjectAtIndex(i);
        }
        <span class="hljs-keyword">if</span> (_bomb-&gt;isVisible()) {
            _bomb-&gt;stopAllActions();
            _bomb-&gt;setVisible(<span class="hljs-keyword">false</span>);
            CCSprite * child;
            child = (CCSprite *) _bomb-&gt;getChildByTag(kSpriteHalo);
            child-&gt;stopAllActions();
            child = (CCSprite *) _bomb-&gt;getChildByTag(kSpriteSparkle);
            child-&gt;stopAllActions();
        }
        <span class="hljs-keyword">if</span> (_shockWave-&gt;isVisible()) {
            _shockWave-&gt;stopAllActions();
            _shockWave-&gt;setVisible(<span class="hljs-keyword">false</span>);
        }
    }
</code></pre><p>类中已经实现了让游戏越来越难的方法。参见<code>increaseDifficulty</code>。</p><h4 id="行动：更新游戏"><a name="行动：更新游戏" href="#行动：更新游戏"></a>行动：更新游戏</h4><p><code>GameLayer::update</code>手工维护了一些定时器，例如：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void GameLayer::update (float dt) {

        if (!_running) return;

        int count;
        int i;
        CCSprite * sprite;

        //update timers

        _meteorTimer += dt;
        if (_meteorTimer &amp;gt; _meteorInterval) {
            _meteorTimer = 0;
            this-&amp;gt;resetMeteor();
        }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> GameLayer::update (<span class="hljs-keyword">float</span> dt) {

        <span class="hljs-keyword">if</span> (!_running) <span class="hljs-keyword">return</span>;

        <span class="hljs-keyword">int</span> count;
        <span class="hljs-keyword">int</span> i;
        CCSprite * sprite;

        <span class="hljs-comment">//update timers</span>

        _meteorTimer += dt;
        <span class="hljs-keyword">if</span> (_meteorTimer &gt; _meteorInterval) {
            _meteorTimer = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">this</span>-&gt;resetMeteor();
        }
</code></pre><p>其中<code>_meteorTimer</code>是一个计时器，时间到了后，向屏幕添加新的流星。还有其他定时器，参见工程代码。</p><blockquote>
<p>其实可以用Action替换这些定时器：<code>CCSequence</code>配合<code>CCDelay</code>再加上一个回调。But there are advantages to using these countdowns. It’s easier to reset them and to change them, and we can take them right into our main loop.</p>
</blockquote><p>下面添加主循环：</p><p>碰撞检测：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    int count;
    CCSprite * sprite;

    // check collision with shockwave
    if (_shockWave-&amp;gt;isVisible()) {
      count = _fallingObjects-&amp;gt;count();

      for (int i = count-1; i &amp;gt;= 0; i--) {
        sprite = (CCSprite *) _fallingObjects-&amp;gt;objectAtIndex(i);
        float diffx = _shockWave-&amp;gt;getPositionX() - sprite-&amp;gt;getPositionX();
        float diffy = _shockWave-&amp;gt;getPositionY() - sprite-&amp;gt;getPositionY();

        if (pow(diffx, 2) + pow(diffy, 2)
            &amp;lt;= pow(_shockWave-&amp;gt;boundingBox().size.width * 0.5f, 2)) {
          sprite-&amp;gt;stopAllActions();
          sprite-&amp;gt;runAction((CCAction *) _explosion-&amp;gt;copy()-&amp;gt;autorelease());
          SimpleAudioEngine::sharedEngine()-&amp;gt;playEffect(&quot;boom.wav&quot;);
          if (sprite-&amp;gt;getTag() == kSpriteMeteor) {
            _shockwaveHits++;
            _score += _shockwaveHits * 13 + _shockwaveHits * 2;
          }
          // play sound
          _fallingObjects-&amp;gt;removeObjectAtIndex(i);
        }
      }
      CCString * value = CCString::createWithFormat(&quot;%i&quot;, _score);
      _scoreDisplay-&amp;gt;setString(value-&amp;gt;getCString());
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">int</span> count;
    CCSprite * sprite;

    <span class="hljs-comment">// check collision with shockwave</span>
    <span class="hljs-keyword">if</span> (_shockWave-&gt;isVisible()) {
      count = _fallingObjects-&gt;count();

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = count-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
        sprite = (CCSprite *) _fallingObjects-&gt;objectAtIndex(i);
        <span class="hljs-keyword">float</span> diffx = _shockWave-&gt;getPositionX() - sprite-&gt;getPositionX();
        <span class="hljs-keyword">float</span> diffy = _shockWave-&gt;getPositionY() - sprite-&gt;getPositionY();

        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pow</span>(diffx, <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>(diffy, <span class="hljs-number">2</span>)
            &lt;= <span class="hljs-built_in">pow</span>(_shockWave-&gt;boundingBox().size.width * <span class="hljs-number">0.5f</span>, <span class="hljs-number">2</span>)) {
          sprite-&gt;stopAllActions();
          sprite-&gt;runAction((CCAction *) _explosion-&gt;copy()-&gt;autorelease());
          SimpleAudioEngine::sharedEngine()-&gt;playEffect(<span class="hljs-string">"boom.wav"</span>);
          <span class="hljs-keyword">if</span> (sprite-&gt;getTag() == kSpriteMeteor) {
            _shockwaveHits++;
            _score += _shockwaveHits * <span class="hljs-number">13</span> + _shockwaveHits * <span class="hljs-number">2</span>;
          }
          <span class="hljs-comment">// play sound</span>
          _fallingObjects-&gt;removeObjectAtIndex(i);
        }
      }
      CCString * value = CCString::createWithFormat(<span class="hljs-string">"%i"</span>, _score);
      _scoreDisplay-&gt;setString(value-&gt;getCString());
    }
</code></pre><p>移动云。下面故意不用<code>CCMoveTo</code>实现，目的是展示Action可以省多少代码。</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    // move clouds
    count = _clouds-&amp;gt;count();
    for (int i = 0; i &amp;lt; count; i++) {
      sprite = (CCSprite *) _clouds-&amp;gt;objectAtIndex(i);
      sprite-&amp;gt;setPositionX(sprite-&amp;gt;getPositionX() + dt * 20);
      if (sprite-&amp;gt;getPositionX()
          &amp;gt; _screenSize.width + sprite-&amp;gt;boundingBox().size.width * 0.5f) {
          sprite-&amp;gt;setPositionX(-sprite-&amp;gt;boundingBox().size.width * 0.5f);
      }
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-comment">// move clouds</span>
    count = _clouds-&gt;count();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
      sprite = (CCSprite *) _clouds-&gt;objectAtIndex(i);
      sprite-&gt;setPositionX(sprite-&gt;getPositionX() + dt * <span class="hljs-number">20</span>);
      <span class="hljs-keyword">if</span> (sprite-&gt;getPositionX()
          &gt; _screenSize.width + sprite-&gt;boundingBox().size.width * <span class="hljs-number">0.5f</span>) {
          sprite-&gt;setPositionX(-sprite-&gt;boundingBox().size.width * <span class="hljs-number">0.5f</span>);
      }
    }
</code></pre><p>We give the player an extra visual cue as to when a bomb is ready to explode, by changing its opacity.</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    if (_bomb-&amp;gt;isVisible()) {
      if (_bomb-&amp;gt;getScale() &amp;gt; 0.3f) {
        if (_bomb-&amp;gt;getOpacity() != 255)
        _bomb-&amp;gt;setOpacity(255);
      }
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">if</span> (_bomb-&gt;isVisible()) {
      <span class="hljs-keyword">if</span> (_bomb-&gt;getScale() &gt; <span class="hljs-number">0.3f</span>) {
        <span class="hljs-keyword">if</span> (_bomb-&gt;getOpacity() != <span class="hljs-number">255</span>)
        _bomb-&gt;setOpacity(<span class="hljs-number">255</span>);
      }
    }
</code></pre><p>主循环中没有更新各个精灵，因为已经通过Action实现了。</p><h4 id="从池中获取对象"><a name="从池中获取对象" href="#从池中获取对象"></a>从池中获取对象</h4><p>To retrieve meteor sprites, we’ll use the <code>resetMeteor</code> method. <code>resetMeteor</code>方法会被<code>update</code>方法代替：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void GameLayer::resetMeteor(void) {
      // 如果屏幕中对象太多
      if (_fallingObjects-&amp;gt;count() &amp;gt; 30) return;

      CCSprite * meteor = (CCSprite *) _meteorPool-&amp;gt;objectAtIndex(_meteorPoolIndex);
      _meteorPoolIndex++;
      if (_meteorPoolIndex == _meteorPool-&amp;gt;count())
          _meteorPoolIndex = 0;

      // 为这个新流星选择开始和结束位置
      int meteor_x = rand() % (int) (_screenSize.width * 0.8f) + _screenSize.width * 0.1f;
      int meteor_target_x = rand() % (int) (_screenSize.width * 0.8f) + _screenSize.width * 0.1f;

      meteor-&amp;gt;stopAllActions();
      meteor-&amp;gt;setPosition(ccp(meteor_x,
          _screenSize.height + meteor-&amp;gt;boundingBox().size.height * 0.5));

      // create action for meteor
      CCActionInterval* rotate = CCRotateBy::create(0.5f ,  -90);
      CCAction* repeatRotate = CCRepeatForever::create ( rotate );
      CCFiniteTimeAction* sequence = CCSequence::create(
          CCMoveTo::create(_meteorSpeed
            ccp(meteor_target_x, _screenSize.height * 0.15f)),
        CCCallFuncN::create(this, callfuncN_selector(GameLayer::fallingObjectDone)),
        NULL);

      meteor-&amp;gt;setVisible ( true );
      meteor-&amp;gt;runAction(repeatRotate);
      meteor-&amp;gt;runAction(sequence);
      _fallingObjects-&amp;gt;addObject(meteor); // 加入到下落对象集合
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> GameLayer::resetMeteor(<span class="hljs-keyword">void</span>) {
      <span class="hljs-comment">// 如果屏幕中对象太多</span>
      <span class="hljs-keyword">if</span> (_fallingObjects-&gt;count() &gt; <span class="hljs-number">30</span>) <span class="hljs-keyword">return</span>;

      CCSprite * meteor = (CCSprite *) _meteorPool-&gt;objectAtIndex(_meteorPoolIndex);
      _meteorPoolIndex++;
      <span class="hljs-keyword">if</span> (_meteorPoolIndex == _meteorPool-&gt;count())
          _meteorPoolIndex = <span class="hljs-number">0</span>;

      <span class="hljs-comment">// 为这个新流星选择开始和结束位置</span>
      <span class="hljs-keyword">int</span> meteor_x = rand() % (<span class="hljs-keyword">int</span>) (_screenSize.width * <span class="hljs-number">0.8f</span>) + _screenSize.width * <span class="hljs-number">0.1f</span>;
      <span class="hljs-keyword">int</span> meteor_target_x = rand() % (<span class="hljs-keyword">int</span>) (_screenSize.width * <span class="hljs-number">0.8f</span>) + _screenSize.width * <span class="hljs-number">0.1f</span>;

      meteor-&gt;stopAllActions();
      meteor-&gt;setPosition(ccp(meteor_x,
          _screenSize.height + meteor-&gt;boundingBox().size.height * <span class="hljs-number">0.5</span>));

      <span class="hljs-comment">// create action for meteor</span>
      CCActionInterval* rotate = CCRotateBy::create(<span class="hljs-number">0.5f</span> ,  -<span class="hljs-number">90</span>);
      CCAction* repeatRotate = CCRepeatForever::create ( rotate );
      CCFiniteTimeAction* sequence = CCSequence::create(
          CCMoveTo::create(_meteorSpeed
            ccp(meteor_target_x, _screenSize.height * <span class="hljs-number">0.15f</span>)),
        CCCallFuncN::create(<span class="hljs-keyword">this</span>, callfuncN_selector(GameLayer::fallingObjectDone)),
        NULL);

      meteor-&gt;setVisible ( <span class="hljs-keyword">true</span> );
      meteor-&gt;runAction(repeatRotate);
      meteor-&gt;runAction(sequence);
      _fallingObjects-&gt;addObject(meteor); <span class="hljs-comment">// 加入到下落对象集合</span>
    }
</code></pre><h3 id="玩游戏！"><a name="玩游戏！" href="#玩游戏！"></a>玩游戏！</h3><p>记得释放资源：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    GameLayer::~GameLayer () {

      //release all retained actions
      CC_SAFE_RELEASE(_growBomb);
      CC_SAFE_RELEASE(_rotateSprite);
      CC_SAFE_RELEASE(_shockwaveSequence);
      CC_SAFE_RELEASE(_swingHealth);
      CC_SAFE_RELEASE(_groundHit);
      CC_SAFE_RELEASE(_explosion);

      //release all retained arrays
      CC_SAFE_RELEASE(_clouds);
      CC_SAFE_RELEASE(_meteorPool);
      CC_SAFE_RELEASE(_healthPool);
      CC_SAFE_RELEASE(_fallingObjects);
    }
&lt;/code&gt;&lt;/pre&gt;">    GameLayer::~GameLayer () {

      <span class="hljs-comment">//release all retained actions</span>
      CC_SAFE_RELEASE(_growBomb);
      CC_SAFE_RELEASE(_rotateSprite);
      CC_SAFE_RELEASE(_shockwaveSequence);
      CC_SAFE_RELEASE(_swingHealth);
      CC_SAFE_RELEASE(_groundHit);
      CC_SAFE_RELEASE(_explosion);

      <span class="hljs-comment">//release all retained arrays</span>
      CC_SAFE_RELEASE(_clouds);
      CC_SAFE_RELEASE(_meteorPool);
      CC_SAFE_RELEASE(_healthPool);
      CC_SAFE_RELEASE(_fallingObjects);
    }
</code></pre><p>Once again, you may refer to <code>7341_04_FINAL_PROJECT.zip</code> if you find any problems running the code.</p><p>And as a bonus, I’ve added another version of the game with an extra type of enemy to deal with: a UFO hell bent on zapping the city! You can find this in <code>7341_04_BONUS_PROJECT.zip</code>.</p><h2 id="5-rock-thought"><a name="5-rock-thought" href="#5-rock-thought"></a>5 Rock thought</h2><p>本章内容：</p><ul>
<li>粒子系统</li>
<li>How to draw primitives (lines, circles, and more) on a CCNode</li>
<li>How to use the vector math helper methods included in Cocos2d-x</li>
</ul><h3 id="the-game-–-rocket-through"><a name="the-game-–-rocket-through" href="#the-game-–-rocket-through"></a>The game – Rocket Through</h3><p>In this sci-fi version of the classic Snake game engine, you control a rocket ship that must move around seven planets collecting tiny supernovas. But here’s the catch: you can only steer the rocket by rotating it around pivot points put in place through touch events. So the vector of movement we set for the rocket ship is at times linear and at times circular.</p><h4 id="the-game-settings"><a name="the-game-settings" href="#the-game-settings"></a>The game settings</h4><p>This is a universal game designed for the regular iPad and then scaled up and down to match the screen resolution of other devices. It is set to play in portrait mode and it does not support multi-touches.</p><h4 id="play-first,-work-later"><a name="play-first,-work-later" href="#play-first,-work-later"></a>Play first, work later</h4><p>Download the <code>7341_05_START_PROJECT.zip</code> and <code>7341_05_FINAL_PROJECT.zip</code> files from this book’s support page. You will once again use the Start Project option to work on; this way you won’t need to type logic or syntax already covered in previous chapters. The Start Project option contains all of the resource files, and all the classes declarations, as well as place-holders for all of the methods inside the classes’ implementation files. We’ll go over these in a moment.</p><p>You should Run the Final Project version to acquaint yourself with the game: By pressing and dragging your finger on the rocket ship you draw a line. Release the touch and you create a pivot point. The ship will rotate around this pivot point until you press again on the ship to release it. Your aim is to collect the bright supernovas and avoid the planets.</p><p><img src="ch4-demo.png" alt=""></p><h4 id="the-start-project"><a name="the-start-project" href="#the-start-project"></a>The start project</h4><p>If you run the Start Project option you should see that the basic game screen is already in place. There is no need to repeat the steps we’ve taken in our previous tutorial for creating a batch node and positioning all the screen sprites. We once again have a <code>_gameBatchNode</code> object and a <code>createGameScreen</code> method.</p><p>By all means read through the code inside the <code>createGameScreen</code> method. Of key importance here is that each planet we create is stored inside <code>_planets</code> <code>CCArray</code>. We also create our <code>_rocket</code> object (class <code>Rocket</code>) and our <code>_lineContainer</code> object (<code>LineContainer</code> class) here. More on these soon.</p><h4 id="屏幕设置"><a name="屏幕设置" href="#屏幕设置"></a>屏幕设置</h4><p>Assuming that you have the Start Project option opened in Xcode, let’s review the screen settings for this game in <code>AppDelegate.cpp</code>, where inside the <code>applicationDidFinishLaunching</code> method you should see this:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    CCSize designSize = CCSize(768, 1024);
    CCEGLView::sharedOpenGLView()-&amp;gt;setDesignResolutionSize(designSize.width,
        designSize.height, kResolutionExactFit);
    float screenRatio = screenSize.height / screenSize.width;
    if (screenSize.width &amp;gt; 768) {
        CCFileUtils::sharedFileUtils()-&amp;gt;setResourceDirectory(&quot;ipadhd&quot;);
        pDirector-&amp;gt;setContentScaleFactor(screenSize.height/designSize.height);
    } else if (screenSize.width &amp;gt; 320) {
        if (screenRatio &amp;gt;= 1.5f) {
            CCFileUtils::sharedFileUtils()-&amp;gt;setResourceDirectory(&quot;iphonehd&quot;);
        } else {
            CCFileUtils::sharedFileUtils()-&amp;gt;setResourceDirectory(&quot;ipad&quot;);
        }
        pDirector-&amp;gt;setContentScaleFactor(screenSize.height/designSize.height);
    } else {
        CCFileUtils::sharedFileUtils()-&amp;gt;setResourceDirectory(&quot;iphone&quot;);
        pDirector-&amp;gt;setContentScaleFactor(screenSize.height/designSize.height);
    }
&lt;/code&gt;&lt;/pre&gt;">    CCSize designSize = CCSize(<span class="hljs-number">768</span>, <span class="hljs-number">1024</span>);
    CCEGLView::sharedOpenGLView()-&gt;setDesignResolutionSize(designSize.width,
        designSize.height, kResolutionExactFit);
    <span class="hljs-keyword">float</span> screenRatio = screenSize.height / screenSize.width;
    <span class="hljs-keyword">if</span> (screenSize.width &gt; <span class="hljs-number">768</span>) {
        CCFileUtils::sharedFileUtils()-&gt;setResourceDirectory(<span class="hljs-string">"ipadhd"</span>);
        pDirector-&gt;setContentScaleFactor(screenSize.height/designSize.height);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (screenSize.width &gt; <span class="hljs-number">320</span>) {
        <span class="hljs-keyword">if</span> (screenRatio &gt;= <span class="hljs-number">1.5f</span>) {
            CCFileUtils::sharedFileUtils()-&gt;setResourceDirectory(<span class="hljs-string">"iphonehd"</span>);
        } <span class="hljs-keyword">else</span> {
            CCFileUtils::sharedFileUtils()-&gt;setResourceDirectory(<span class="hljs-string">"ipad"</span>);
        }
        pDirector-&gt;setContentScaleFactor(screenSize.height/designSize.height);
    } <span class="hljs-keyword">else</span> {
        CCFileUtils::sharedFileUtils()-&gt;setResourceDirectory(<span class="hljs-string">"iphone"</span>);
        pDirector-&gt;setContentScaleFactor(screenSize.height/designSize.height);
    }
</code></pre><p>The iPad is the oddball in terms of screen size: it has a 1.33 screen ratio (longer side divided by shorter side). 多数Android设备在<code>1.6</code>和<code>1.77</code>之间，with a few sharing the iPhone screen ratio of 1.5.</p><p>Why should you care? In this game most sprites are circles and the difference in screen ratio would cause them to look squished when ported to different screens using the <code>kResolutionExactFit</code> parameter, which distorts your game screen to fit the screen of the device. 有多种解决方式。例如，可以以iPhone的比率为设计目标（因为它接近各种比率的平均值），然后使用<code>kResolutionShowAll</code>。这将产生黑边，但不会使精灵变形（第8章将使用该方法）。But here I used another method, I created sprite sheets that account for the squished look of the sprites in different screen ratios, counteracting the distortion. You, or your designer, could produce art for different screen ratios, such as 1.3, 1.5, 1.6, and 1.7, and pack different sets of images for different device families. For the Apple family, the solution shown here works very well and we can use the entire screen through <code>kResolutionExactFit</code>.</p><p>The following image shows two sets of images found in the sprite sheets. Notice the distortion in the iPhone ones. In the actual game this distortion will disappear as it will counteract the change from a 1.3 screen ratio to a 1.5:</p><p><img src="ch4-distortion_images.png" alt=""></p><h3 id="什么是粒子"><a name="什么是粒子" href="#什么是粒子"></a>什么是粒子</h3><p>粒子通过 <strong>ParticleDesigner</strong> 创建。</p><h4 id="行动：创建粒子系统"><a name="行动：创建粒子系统" href="#行动：创建粒子系统"></a>行动：创建粒子系统</h4><p>需要一个XML文件描述例子系统的属性。ParticleDesigner 将粒子系统数据导出到plist文件。这个文件用于创建<code>CCParticleSystemQuad</code>对象。From Cocos2d-x you can modify any of these settings through setters inside <code>CCParticleSystem</code>.</p><p><code>GameLayer.cpp</code>的<code>createParticle</code>方法：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    // CCParticleSystem * _jet;
    _jet = CCParticleSystemQuad::create(&quot;jet.plist&quot;);
    _jet-&amp;gt;setSourcePosition(ccp(-_rocket-&amp;gt;getRadius() * 0.8f,0));
    _jet-&amp;gt;setAngle(180);
    _jet-&amp;gt;stopSystem();
    this-&amp;gt;addChild(_jet, kBackground);

    _boom = CCParticleSystemQuad::create(&quot;boom.plist&quot;);
    _boom-&amp;gt;stopSystem();
    this-&amp;gt;addChild(_boom, kForeground);

    _comet = CCParticleSystemQuad::create(&quot;comet.plist&quot;);
    _comet-&amp;gt;stopSystem();
    _comet-&amp;gt;setPosition(ccp(0, _screenSize.height * 0.6f));
    _comet-&amp;gt;setVisible(false);
    this-&amp;gt;addChild(_comet, kForeground);

    _pickup = CCParticleSystemQuad::create(&quot;plink.plist&quot;);
    _pickup-&amp;gt;stopSystem();
    this-&amp;gt;addChild(_pickup, kMiddleground);

    _warp = CCParticleSystemQuad::create(&quot;warp.plist&quot;);
    _warp-&amp;gt;setPosition(_rocket-&amp;gt;getPosition());
    this-&amp;gt;addChild(_warp, kBackground);

    _star = CCParticleSystemQuad::create(&quot;star.plist&quot;);
    _star-&amp;gt;stopSystem();
    _star-&amp;gt;setVisible(false);
    this-&amp;gt;addChild(_star, kBackground, kSpriteStar);
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-comment">// CCParticleSystem * _jet;</span>
    _jet = CCParticleSystemQuad::create(<span class="hljs-string">"jet.plist"</span>);
    _jet-&gt;setSourcePosition(ccp(-_rocket-&gt;getRadius() * <span class="hljs-number">0.8f</span>,<span class="hljs-number">0</span>));
    _jet-&gt;setAngle(<span class="hljs-number">180</span>);
    _jet-&gt;stopSystem();
    <span class="hljs-keyword">this</span>-&gt;addChild(_jet, kBackground);

    _boom = CCParticleSystemQuad::create(<span class="hljs-string">"boom.plist"</span>);
    _boom-&gt;stopSystem();
    <span class="hljs-keyword">this</span>-&gt;addChild(_boom, kForeground);

    _comet = CCParticleSystemQuad::create(<span class="hljs-string">"comet.plist"</span>);
    _comet-&gt;stopSystem();
    _comet-&gt;setPosition(ccp(<span class="hljs-number">0</span>, _screenSize.height * <span class="hljs-number">0.6f</span>));
    _comet-&gt;setVisible(<span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">this</span>-&gt;addChild(_comet, kForeground);

    _pickup = CCParticleSystemQuad::create(<span class="hljs-string">"plink.plist"</span>);
    _pickup-&gt;stopSystem();
    <span class="hljs-keyword">this</span>-&gt;addChild(_pickup, kMiddleground);

    _warp = CCParticleSystemQuad::create(<span class="hljs-string">"warp.plist"</span>);
    _warp-&gt;setPosition(_rocket-&gt;getPosition());
    <span class="hljs-keyword">this</span>-&gt;addChild(_warp, kBackground);

    _star = CCParticleSystemQuad::create(<span class="hljs-string">"star.plist"</span>);
    _star-&gt;stopSystem();
    _star-&gt;setVisible(<span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">this</span>-&gt;addChild(_star, kBackground, kSpriteStar);
</code></pre><p>所有的例子系统都被添加到<code>GameLayer</code>的孩子；不能添加到<code>CCSpriteBatchNode</code>。创建后要调用<code>stopSystem()</code>，否则被添加到一个节点时会立即执行。</p><blockquote>
<p>Cocos2d-x携带了一些常用例子系统，可以在此基础上修改。If you go to the test folder at: <code>samples/TestCpp/Classes/ParticleTest</code> you will see examples of these systems being used. The actual particles data files are found at: <code>samples/TestCpp/Resources/Particles</code>.</p>
</blockquote><h3 id="创建网格"><a name="创建网格" href="#创建网格"></a>创建网格</h3><p>This grid is created inside the <code>createStarGrid</code> method in <code>GameLayer.cpp</code>. What the method does is determine all of the possible <strong>spots</strong> on the screen where we can place the <code>_star</code> particle system.</p><p>用<code>_grid</code>存储所有可用的地点，as it will be easier to <em>shuffle</em> the list this way than to use CCArray:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    std::vector&amp;lt;CCPoint&amp;gt; _grid;
&lt;/code&gt;&lt;/pre&gt;">    std::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;CCPoint&gt;</span> _grid;
</code></pre><p>该方法将屏幕分成多个网格。每个 32 x 32 像素，ignoring the areas too close to the screen borders (<code>gridFrame</code>). Then we check the distance between each cell and the planet sprites stored inside CCArray <code>_planets</code>. If the cell is far enough from the planets we store it inside the <code>_grid</code> vector as <code>CCPoint</code>.</p><p>In the following image you can get an idea of the result we’re after. We do not want any of the white cells overlapping any of the planets.</p><p><img src="ch4-grid.png" alt=""></p><p>We output a message to the console with <code>CCLog</code> stating how many cells we end up with:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    CCLog(&quot;POSSIBLE STARS: %i&quot;, _grid.size());
&lt;/code&gt;&lt;/pre&gt;">    CCLog(<span class="hljs-string">"POSSIBLE STARS: %i"</span>, _grid.size());
</code></pre><p>This vector list will be shuffled at each new game, so we end up with a random sequence of possible positions for our star:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    std::random_shuffle(_grid.begin(), _grid.end());
&lt;/code&gt;&lt;/pre&gt;">    std::random_shuffle(_grid.begin(), _grid.end());
</code></pre><p>This way we never place a star on top of a planet or too close to it that the rocket could not reach it without colliding with the planet.</p><h3 id="绘制基本图形"><a name="绘制基本图形" href="#绘制基本图形"></a>绘制基本图形</h3><p><code>LineContainer.cpp</code>是<code>CCNode</code>的一个子类，允许我们在屏幕上绘制线和圆。每个<code>CCNode</code>都有一个<code>draw</code>方法。This is where the OpenGL drawing of our sprites take place, and it gets called automatically by the framework during rendering (so up to 60 times a second). So in order to draw something yourself, you just need to override this method; and then in order to draw primitives, you use the helper methods from a Cocos2d-x class called <code>CCDrawingPrimitives.cpp</code>.</p><p>The methods we’ll use are: <code>ccDrawLine</code> and <code>ccDrawCircle</code>.</p><h4 id="行动：绘制"><a name="行动：绘制" href="#行动：绘制"></a>行动：绘制</h4><p>在<code>LineContainer.cpp</code>中实现绘制。Basically <code>LineContainer</code> will be used to display the lines that the player draws on screen in order to manipulate <code>_rocket</code> sprite, as well as display an energy bar that acts as a sort of timer in our game:</p><p>改变<code>CCNode</code>的<code>draw</code>方法：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    switch (_lineType) {
        case LINE_NONE:
            break;
        case LINE_TEMP:
            ccDrawColor4F(1.0, 1.0, 1.0, 1.0);
            ccDrawLine(_tip, _pivot);
            ccDrawCircle(_pivot, 10, CC_DEGREES_TO_RADIANS(360), 10, false);
            break;
        case LINE_DASHED:
            ccDrawColor4F(1.0, 1.0, 1.0, 1.0);
            ccDrawCircle(_pivot, 10, M_PI, 10, false);
            int segments = _lineLength / (_dash + _dashSpace);
            float t = 0.0f;
            float x_;
            float y_;
            for (int i = 0; i &amp;lt; segments + 1; i++) {
                x_ = _pivot.x + t * (_tip.x - _pivot.x);
                y_ = _pivot.y + t * (_tip.y - _pivot.y);
                ccDrawCircle(ccp ( x_, y_ ), 4, M_PI, 6, false);
                t += (float) 1 / segments;
            }
            break;
    }

    // 下面是绘制能量条
    ccDrawColor4F(0.0, 0.0, 0.0, 1.0);
    ccDrawLine(ccp(_energyLineX, _screenSize.height * 0.1f),
        ccp(_energyLineX, _screenSize.height * 0.9f));
    ccDrawColor4F(1.0, 0.5, 0.0, 1.0);
    ccDrawLine(ccp(_energyLineX, _screenSize.height * 0.1f),
        ccp(_energyLineX, _screenSize.height * 0.1f + _energy * _energyHeight ));
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">switch</span> (_lineType) {
        <span class="hljs-keyword">case</span> LINE_NONE:
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> LINE_TEMP:
            ccDrawColor4F(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);
            ccDrawLine(_tip, _pivot);
            ccDrawCircle(_pivot, <span class="hljs-number">10</span>, CC_DEGREES_TO_RADIANS(<span class="hljs-number">360</span>), <span class="hljs-number">10</span>, <span class="hljs-keyword">false</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> LINE_DASHED:
            ccDrawColor4F(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>);
            ccDrawCircle(_pivot, <span class="hljs-number">10</span>, M_PI, <span class="hljs-number">10</span>, <span class="hljs-keyword">false</span>);
            <span class="hljs-keyword">int</span> segments = _lineLength / (_dash + _dashSpace);
            <span class="hljs-keyword">float</span> t = <span class="hljs-number">0.0f</span>;
            <span class="hljs-keyword">float</span> x_;
            <span class="hljs-keyword">float</span> y_;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; segments + <span class="hljs-number">1</span>; i++) {
                x_ = _pivot.x + t * (_tip.x - _pivot.x);
                y_ = _pivot.y + t * (_tip.y - _pivot.y);
                ccDrawCircle(ccp ( x_, y_ ), <span class="hljs-number">4</span>, M_PI, <span class="hljs-number">6</span>, <span class="hljs-keyword">false</span>);
                t += (<span class="hljs-keyword">float</span>) <span class="hljs-number">1</span> / segments;
            }
            <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-comment">// 下面是绘制能量条</span>
    ccDrawColor4F(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);
    ccDrawLine(ccp(_energyLineX, _screenSize.height * <span class="hljs-number">0.1f</span>),
        ccp(_energyLineX, _screenSize.height * <span class="hljs-number">0.9f</span>));
    ccDrawColor4F(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);
    ccDrawLine(ccp(_energyLineX, _screenSize.height * <span class="hljs-number">0.1f</span>),
        ccp(_energyLineX, _screenSize.height * <span class="hljs-number">0.1f</span> + _energy * _energyHeight ));
</code></pre><p>If  _lineType is LINE_TEMP this means that the player is currently dragging a finger away<br>from the  _rocket object and we want to show a white line from the _rocket current<br>position to the player’s current touch position. These points are called, respectively, tip<br>and pivot. We also draw a circle directly on the pivot point.</p><p>If  _lineType is LINE_DASHED then this means that the player has removed his or her<br>finger from the screen and set a new pivot point for the  _rocket to rotate around. We draw<br>a white dotted line, using what is known as the bezier linear formula to draw a series of tiny<br>circles from the  _rocket’s current position and the pivot point.</p><p>在<code>LineContainer.cpp</code>构造器中，注意到设置了每个ccDraw使用的线宽：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    glLineWidth(8.0 * CC_CONTENT_SCALE_FACTOR());
&lt;/code&gt;&lt;/pre&gt;">    glLineWidth(<span class="hljs-number">8.0</span> * CC_CONTENT_SCALE_FACTOR());
</code></pre><p>但注意框架不会负责缩放这个值。当遇到不会缩放的值时，你需要手写逻辑，乘以<code>CC_CONTENT_SCALE_FACTOR()</code>（在<code>AppDelegate.cpp</code>中设置的缩放）。</p><h3 id="火箭精灵"><a name="火箭精灵" href="#火箭精灵"></a>火箭精灵</h3><p>在<code>Rocket.cpp</code>中，根据一个标志设置火箭的纹理：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    if (flag) {
        this-&amp;gt;setDisplayFrame(CCSpriteFrameCache::sharedSpriteFrameCache()
            -&amp;gt;spriteFrameByName(&quot;rocket_on.png&quot;));
    } else {
        this-&amp;gt;setDisplayFrame(CCSpriteFrameCache::sharedSpriteFrameCache()
            -&amp;gt;spriteFrameByName(&quot;rocket.png&quot;));
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">if</span> (flag) {
        <span class="hljs-keyword">this</span>-&gt;setDisplayFrame(CCSpriteFrameCache::sharedSpriteFrameCache()
            -&gt;spriteFrameByName(<span class="hljs-string">"rocket_on.png"</span>));
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>-&gt;setDisplayFrame(CCSpriteFrameCache::sharedSpriteFrameCache()
            -&gt;spriteFrameByName(<span class="hljs-string">"rocket.png"</span>));
    }
</code></pre><h4 id="行动：更新火箭"><a name="行动：更新火箭" href="#行动：更新火箭"></a>行动：更新火箭</h4><p>游戏主循环每次循环都会调用火箭的<code>update</code>方法：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    CCPoint position = this-&amp;gt;getPosition();
    if (_rotationOrientation == ROTATE_NONE) {
        position.x += _vector.x * dt;
        position.y += _vector.y * dt;
    } else {
        // 根据当前位置、轴点和旋转焦点确定下一个位置
        CCPoint rotatedPoint = ccpRotateByAngle(position, _pivot, _angularSpeed * dt);
        position.x = rotatedPoint.x;
        position.y = rotatedPoint.y;
        float rotatedAngle;
        CCPoint clockwise = ccpRPerp( ccpSub(position, _pivot) );
        if (_rotationOrientation == ROTATE_COUNTER) {
            rotatedAngle = atan2 (-1 * clockwise.y, -1 * clockwise.x);
        } else {
            rotatedAngle = atan2 (clockwise.y, clockwise.x);
        }
        //update rocket vector
        _vector.x = _speed * cos (rotatedAngle);
        _vector.y = _speed * sin (rotatedAngle);
        this-&amp;gt;setRotationFromVector();
        if (this-&amp;gt;getRotation() &amp;gt; 0) {
            this-&amp;gt;setRotation( fmodf(this-&amp;gt;getRotation(), 360.0f));
        } else {
            this-&amp;gt;setRotation( fmodf(this-&amp;gt;getRotation(), -360.0f));
        }
    }
&lt;/code&gt;&lt;/pre&gt;">    CCPoint position = <span class="hljs-keyword">this</span>-&gt;getPosition();
    <span class="hljs-keyword">if</span> (_rotationOrientation == ROTATE_NONE) {
        position.x += _vector.x * dt;
        position.y += _vector.y * dt;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 根据当前位置、轴点和旋转焦点确定下一个位置</span>
        CCPoint rotatedPoint = ccpRotateByAngle(position, _pivot, _angularSpeed * dt);
        position.x = rotatedPoint.x;
        position.y = rotatedPoint.y;
        <span class="hljs-keyword">float</span> rotatedAngle;
        CCPoint clockwise = ccpRPerp( ccpSub(position, _pivot) );
        <span class="hljs-keyword">if</span> (_rotationOrientation == ROTATE_COUNTER) {
            rotatedAngle = <span class="hljs-built_in">atan2</span> (-<span class="hljs-number">1</span> * clockwise.y, -<span class="hljs-number">1</span> * clockwise.x);
        } <span class="hljs-keyword">else</span> {
            rotatedAngle = <span class="hljs-built_in">atan2</span> (clockwise.y, clockwise.x);
        }
        <span class="hljs-comment">//update rocket vector</span>
        _vector.x = _speed * <span class="hljs-built_in">cos</span> (rotatedAngle);
        _vector.y = _speed * <span class="hljs-built_in">sin</span> (rotatedAngle);
        <span class="hljs-keyword">this</span>-&gt;setRotationFromVector();
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;getRotation() &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">this</span>-&gt;setRotation( fmodf(<span class="hljs-keyword">this</span>-&gt;getRotation(), <span class="hljs-number">360.0f</span>));
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>-&gt;setRotation( fmodf(<span class="hljs-keyword">this</span>-&gt;getRotation(), -<span class="hljs-number">360.0f</span>));
        }
    }
</code></pre><blockquote>
<p>使用<code>CCNode</code>的受保护字段还是使用其setter方法。调用setter一般会将<code>dirty</code>置位，将导致精灵被重绘。直接改变属性不会置位<code>dirty</code>，因此有可能看不到改变。</p>
</blockquote><p>我们不能用<code>CCAction</code>实现旋转，因为旋转更新的太快了｛｛参数配置更新快，不是说旋转的快｝｝，而<code>CCAction</code>需要时间初始化和运行。</p><h4 id="行动：处理触摸"><a name="行动：处理触摸" href="#行动：处理触摸"></a>行动：处理触摸</h4><p>在<code>GameLayer.cpp</code>的<code>ccTouchesBegan</code>方法中：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    if (!_running) return;
    CCTouch *touch = (CCTouch *)pTouches-&amp;gt;anyObject();
    if (touch) {
        CCPoint tap = touch-&amp;gt;getLocation();
        // track if tapping on ship
        float dx = _rocket-&amp;gt;getPositionX() - tap.x;
        float dy = _rocket-&amp;gt;getPositionY() - tap.y;
        if (dx * dx + dy * dy &amp;lt;= pow(_rocket-&amp;gt;getRadius() * 1.2, 2)) {
           // clear lines
           _lineContainer-&amp;gt;setLineType ( LINE_NONE );
           _rocket-&amp;gt;setRotationOrientation ( ROTATE_NONE );
           _drawing = true;
        }
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">if</span> (!_running) <span class="hljs-keyword">return</span>;
    CCTouch *touch = (CCTouch *)pTouches-&gt;anyObject();
    <span class="hljs-keyword">if</span> (touch) {
        CCPoint tap = touch-&gt;getLocation();
        <span class="hljs-comment">// track if tapping on ship</span>
        <span class="hljs-keyword">float</span> dx = _rocket-&gt;getPositionX() - tap.x;
        <span class="hljs-keyword">float</span> dy = _rocket-&gt;getPositionY() - tap.y;
        <span class="hljs-keyword">if</span> (dx * dx + dy * dy &lt;= <span class="hljs-built_in">pow</span>(_rocket-&gt;getRadius() * <span class="hljs-number">1.2</span>, <span class="hljs-number">2</span>)) {
           <span class="hljs-comment">// clear lines</span>
           _lineContainer-&gt;setLineType ( LINE_NONE );
           _rocket-&gt;setRotationOrientation ( ROTATE_NONE );
           _drawing = <span class="hljs-keyword">true</span>;
        }
    }
</code></pre><p>判断是否点了暂停：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    if (!_running) return;
    CCTouch *touch = (CCTouch *)pTouches-&amp;gt;anyObject();
    if(touch) {
        CCPoint tap = touch-&amp;gt;getLocation();
        if (_pauseBtn-&amp;gt;boundingBox().containsPoint(tap)) {
            _paused-&amp;gt;setVisible(true);
            _state = kGamePaused;
            _pauseBtn-&amp;gt;setDisplayFrame(
                CCSpriteFrameCache::sharedSpriteFrameCache()
                    -&amp;gt;spriteFrameByName(&quot;btn_pause_on.png&quot;));
            _running = false;
            return;
        }
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">if</span> (!_running) <span class="hljs-keyword">return</span>;
    CCTouch *touch = (CCTouch *)pTouches-&gt;anyObject();
    <span class="hljs-keyword">if</span>(touch) {
        CCPoint tap = touch-&gt;getLocation();
        <span class="hljs-keyword">if</span> (_pauseBtn-&gt;boundingBox().containsPoint(tap)) {
            _paused-&gt;setVisible(<span class="hljs-keyword">true</span>);
            _state = kGamePaused;
            _pauseBtn-&gt;setDisplayFrame(
                CCSpriteFrameCache::sharedSpriteFrameCache()
                    -&gt;spriteFrameByName(<span class="hljs-string">"btn_pause_on.png"</span>));
            _running = <span class="hljs-keyword">false</span>;
            <span class="hljs-keyword">return</span>;
        }
    }
</code></pre><p>What follows next is even more math, using the amazingly helpful methods from Cocos2d-x that are related to vector math (ccpRPerp, ccpDot, ccpSub, to name a few) some of which we’ve seen already in the Rocket class:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;        CCPoint clockwise = ccpRPerp(ccpSub(_rocket-&amp;gt;getPosition(), _rocket-&amp;gt;getPivot()));
        float dot = ccpDot ( clockwise, _rocket-&amp;gt;getVector() );
        if (dot &amp;gt; 0) {
            _rocket-&amp;gt;setAngularSpeed (_rocket-&amp;gt;getAngularSpeed() * -1 );
            _rocket-&amp;gt;setRotationOrientation ( ROTATE_CLOCKWISE);
            _rocket-&amp;gt;setTargetRotation (CC_RADIANS_TO_DEGREES(atan2(clockwise.y, clockwise.x) ) );
            } else {
            _rocket-&amp;gt;setRotationOrientation ( ROTATE_COUNTER );
            _rocket-&amp;gt;setTargetRotation (CC_RADIANS_TO_DEGREES(atan2(-1 * clockwise.y, -1 * clockwise.x) ) );
        }
        _lineContainer-&amp;gt;setLineType ( LINE_DASHED );
    }
}
&lt;/code&gt;&lt;/pre&gt;">        CCPoint clockwise = ccpRPerp(ccpSub(_rocket-&gt;getPosition(), _rocket-&gt;getPivot()));
        <span class="hljs-keyword">float</span> dot = ccpDot ( clockwise, _rocket-&gt;getVector() );
        <span class="hljs-keyword">if</span> (dot &gt; <span class="hljs-number">0</span>) {
            _rocket-&gt;setAngularSpeed (_rocket-&gt;getAngularSpeed() * -<span class="hljs-number">1</span> );
            _rocket-&gt;setRotationOrientation ( ROTATE_CLOCKWISE);
            _rocket-&gt;setTargetRotation (CC_RADIANS_TO_DEGREES(<span class="hljs-built_in">atan2</span>(clockwise.y, clockwise.x) ) );
            } <span class="hljs-keyword">else</span> {
            _rocket-&gt;setRotationOrientation ( ROTATE_COUNTER );
            _rocket-&gt;setTargetRotation (CC_RADIANS_TO_DEGREES(<span class="hljs-built_in">atan2</span>(-<span class="hljs-number">1</span> * clockwise.y, -<span class="hljs-number">1</span> * clockwise.x) ) );
        }
        _lineContainer-&gt;setLineType ( LINE_DASHED );
    }
}
</code></pre><h3 id="游戏循环"><a name="游戏循环" href="#游戏循环"></a>游戏循环</h3><p>主循环负责碰撞检测，更新<code>_lineContainer</code>中的点，adjusting our <code>_jet</code> particle system to our <code>_rocket</code> sprite, and a few other things.</p><p>实现主<code>update</code>方法：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    if (!_running) return;

    if (_lineContainer-&amp;gt;getLineType() != LINE_NONE) {
        _lineContainer-&amp;gt;setTip (_rocket-&amp;gt;getPosition() );

    }
    // track collision with sides
    if (_rocket-&amp;gt;collidedWithSides()) {
        _lineContainer-&amp;gt;setLineType ( LINE_NONE );
    }
    _rocket-&amp;gt;update(dt);
    // update jet particle so it follows rocket
    if (!_jet-&amp;gt;isActive()) _jet-&amp;gt;resetSystem();
    _jet-&amp;gt;setRotation(_rocket-&amp;gt;getRotation());
    _jet-&amp;gt;setPosition(_rocket-&amp;gt;getPosition());
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">if</span> (!_running) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">if</span> (_lineContainer-&gt;getLineType() != LINE_NONE) {
        _lineContainer-&gt;setTip (_rocket-&gt;getPosition() );

    }
    <span class="hljs-comment">// track collision with sides</span>
    <span class="hljs-keyword">if</span> (_rocket-&gt;collidedWithSides()) {
        _lineContainer-&gt;setLineType ( LINE_NONE );
    }
    _rocket-&gt;update(dt);
    <span class="hljs-comment">// update jet particle so it follows rocket</span>
    <span class="hljs-keyword">if</span> (!_jet-&gt;isActive()) _jet-&gt;resetSystem();
    _jet-&gt;setRotation(_rocket-&gt;getRotation());
    _jet-&gt;setPosition(_rocket-&gt;getPosition());
</code></pre><h3 id="kill-and-reset"><a name="kill-and-reset" href="#kill-and-reset"></a>Kill and reset</h3><h2 id="6-快速原型开发：rush-hour"><a name="6-快速原型开发：rush-hour" href="#6-快速原型开发：rush-hour"></a>6 快速原型开发：Rush Hour</h2><ul>
<li>How to quickly create placeholder sprites</li>
<li>How to code collision for a platform game</li>
<li>How to create varied terrain for a side-scroller</li>
</ul><h3 id="游戏：victorian-rush-hour"><a name="游戏：victorian-rush-hour" href="#游戏：victorian-rush-hour"></a>游戏：Victorian Rush Hour</h3><p>In this game you control a cyclist in Victorian London trying to avoid the traffic on his way<br>home. For reasons no one can explain, he’s riding his bike on top of the buildings. As the<br>player, it is your job to ensure he makes it.</p><p>The controls are very simple: you tap the screen to make the cyclist jump. While he’s in the<br>air, if you tap the screen again the cyclist will open his trusty umbrella, either slowing his<br>descent or adding a boost to his jump.</p><p>This game is of a type commonly known as a dash game, a genre that has become increasingly popular online and on various app stores.</p><p>这个游戏中，地形是敌人。</p><p>The game is an universal application, designed for the iPad’s retina display but with support for other display sizes. It is played in landscape mode and it does not support multi-touch.</p><h3 id="快速原型"><a name="快速原型" href="#快速原型"></a>快速原型</h3><p>用矩形作为精灵的快速原型，验证游戏创意。</p><h4 id="行动：创建占位符精灵"><a name="行动：创建占位符精灵" href="#行动：创建占位符精灵"></a>行动：创建占位符精灵</h4><p>从<code>7341_06_START_PROJECT.zip</code>开始。</p><p>向<code>GameLayer.cpp</code>，<code>createGameScreen</code>最后添加三行：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    CCSprite * quickSprite = CCSprite::create(&quot;blank.png&quot;);
    quickSprite-&amp;gt;setTextureRect(CCRectMake(0, 0, 100, 100));
    quickSprite-&amp;gt;setColor(ccc3(255,255,255));
    quickSprite-&amp;gt;setPosition(ccp(_screenSize.width * 0.5,
        _screenSize.height * 0.5));
    this-&amp;gt;addChild(quickSprite);
&lt;/code&gt;&lt;/pre&gt;">    CCSprite * quickSprite = CCSprite::create(<span class="hljs-string">"blank.png"</span>);
    quickSprite-&gt;setTextureRect(CCRectMake(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>));
    quickSprite-&gt;setColor(ccc3(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>));
    quickSprite-&gt;setPosition(ccp(_screenSize.width * <span class="hljs-number">0.5</span>,
        _screenSize.height * <span class="hljs-number">0.5</span>));
    <span class="hljs-keyword">this</span>-&gt;addChild(quickSprite);
</code></pre><p><code>blank.png</code>是一个1像素的白色块。</p><p>删掉上述代码，改成：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;_gameBatchNode = CCSpriteBatchNode::create(&quot;blank.png&quot;, 200);
this-&amp;gt;addChild(_gameBatchNode, kMiddleground);
&lt;/code&gt;&lt;/pre&gt;">_gameBatchNode = CCSpriteBatchNode::create(<span class="hljs-string">"blank.png"</span>, <span class="hljs-number">200</span>);
<span class="hljs-keyword">this</span>-&gt;addChild(_gameBatchNode, kMiddleground);
</code></pre><p>于是整个游戏只需要一个图片。</p><p>继续：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    _terrain = Terrain::create();
    _gameBatchNode-&amp;gt;addChild(_terrain, kMiddleground);

    _player = Player::create();
    _gameBatchNode-&amp;gt;addChild(_player, kBackground);
&lt;/code&gt;&lt;/pre&gt;">    _terrain = Terrain::create();
    _gameBatchNode-&gt;addChild(_terrain, kMiddleground);

    _player = Player::create();
    _gameBatchNode-&gt;addChild(_player, kBackground);
</code></pre><h3 id="player对象"><a name="player对象" href="#player对象"></a>Player对象</h3><p>表示自行车。It will jump, float, and collide with the <code>_terrain</code> object. It’s x speed is passed to the <code>_terrain</code> object causing it to move, side scrolling to the left of the screen.</p><p><code>Player</code>派生自<code>GameSprite</code>。This one has getters and setters for next position, vector of movement, and the sprite’s width and height.</p><p>The Player interface has inline helper methods to retrieve information about its rectangle boundaries related to its current position (left, right, top, bottom) and its next position (next_left, next_right, next_top, next_bottom). These will be used in collision detection with the <code>_terrain</code>  object.</p><h3 id="block对象"><a name="block对象" href="#block对象"></a>Block对象</h3><p><code>_terrain</code>对象由多个Block对象构成。可能是一个建筑物，或之间的缝隙。有四纵不同的建筑。Block对象可以有不同的宽度和高度。</p><p><code>Block</code>也派生自<code>GameSprite</code>， and it also has inline helper methods to retrieve information about its boundaries, but only in relation to its current position, since Block don’t technically move.</p><h3 id="terrain对象"><a name="terrain对象" href="#terrain对象"></a>Terrain对象</h3><p>This object contains the individual Block objects that form the landscape. It contains just enough Block objects to <strong>fill</strong> the screen, and as the <code>_terrain</code> object scrolls to the left, the Block objects that leave the screen are moved to the far right side of the <code>_terrain</code> and <strong>reused</strong> as new Blocks, ensuring continuous scrolling.</p><p>The <code>_terrain</code> object also is responsible for collision checks with the <code>_player</code> object, since it has quick access to all information we’ll need for collision detection; namely the list of blocks currently on the screen, their size, type, and position. Our main loop then will call on the <code>Terrain</code> object to test for player collision.</p><h4 id="行动：编写player"><a name="行动：编写player" href="#行动：编写player"></a>行动：编写Player</h4><p>打开<code>Player.cpp</code>。_player is created through a static method that uses our  blank.png file to texture the sprite. That method also makes a call to <code>initPlayer</code>, and this is what you should type for that method:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void Player::initPlayer () {
        this-&amp;gt;setAnchorPoint(ccp(0.5f, 1.0f));
        this-&amp;gt;setPosition(ccp(_screenSize.width * 0.2f,
            _nextPosition.y));
        _height = 228;
        _width = 180;
        this-&amp;gt;setTextureRect(CCRectMake(0, 0, _width, _height));
        this-&amp;gt;setColor(ccc3(255,255,255));
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> Player::initPlayer () {
        <span class="hljs-keyword">this</span>-&gt;setAnchorPoint(ccp(<span class="hljs-number">0.5f</span>, <span class="hljs-number">1.0f</span>));
        <span class="hljs-keyword">this</span>-&gt;setPosition(ccp(_screenSize.width * <span class="hljs-number">0.2f</span>,
            _nextPosition.y));
        _height = <span class="hljs-number">228</span>;
        _width = <span class="hljs-number">180</span>;
        <span class="hljs-keyword">this</span>-&gt;setTextureRect(CCRectMake(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, _width, _height));
        <span class="hljs-keyword">this</span>-&gt;setColor(ccc3(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>));
    }
</code></pre><p>为了动画方便，<code>_player</code>对象的锚点放在顶部中间。</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void Player::setFloating (bool value) {
        if (_floating == value) return;
        if (value &amp;amp;&amp;amp; _hasFloated) return;
        _floating = value;
        if (value) {
            _hasFloated = true;
            _vector.y += PLAYER_JUMP * 0.5f;
        }
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> Player::setFloating (<span class="hljs-keyword">bool</span> value) {
        <span class="hljs-keyword">if</span> (_floating == value) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span> (value &amp;&amp; _hasFloated) <span class="hljs-keyword">return</span>;
        _floating = value;
        <span class="hljs-keyword">if</span> (value) {
            _hasFloated = <span class="hljs-keyword">true</span>;
            _vector.y += PLAYER_JUMP * <span class="hljs-number">0.5f</span>;
        }
    }
</code></pre><p>The <code>_hasFloated</code> property  will ensure the player can only open the umbrella once while in the air. And when we set <code>_floating</code> to true we give the <code>_player</code> y vector a boost.</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void Player::update (float dt) {
        if (_speed + ACCELERATION &amp;lt;= _maxSpeed) {
            _speed += ACCELERATION;
        } else {
            _speed = _maxSpeed;
        }

        _vector.x = _speed;
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> Player::update (<span class="hljs-keyword">float</span> dt) {
        <span class="hljs-keyword">if</span> (_speed + ACCELERATION &lt;= _maxSpeed) {
            _speed += ACCELERATION;
        } <span class="hljs-keyword">else</span> {
            _speed = _maxSpeed;
        }

        _vector.x = _speed;
</code></pre><p>随着时间增加增加<code>_maxSpeed</code>，以增加游戏难度。</p><p>Next, we update  the  _player object based on its _state of movement:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    switch (_state) {
        case kPlayerMoving:
            _vector.y -= GRAVITY;
            if (_hasFloated) _hasFloated = false;
            break;
       case kPlayerFalling:
          if (_floating) {
             _vector.y -= FLOATNG_GRAVITY;
             _vector.x *= FLOATING_FRICTION;
          } else {
             _vector.y -= GRAVITY;
             _vector.x *= AIR_FRICTION;
             _floatingTimer = 0;
          }
          break;
       case kPlayerDying:
          _vector.y -= GRAVITY;
          _vector.x = -_speed;
          this-&amp;gt;setPositionX(this-&amp;gt;getPositionX() + _vector.x);
          break;
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">switch</span> (_state) {
        <span class="hljs-keyword">case</span> kPlayerMoving:
            _vector.y -= GRAVITY;
            <span class="hljs-keyword">if</span> (_hasFloated) _hasFloated = <span class="hljs-keyword">false</span>;
            <span class="hljs-keyword">break</span>;
       <span class="hljs-keyword">case</span> kPlayerFalling:
          <span class="hljs-keyword">if</span> (_floating) {
             _vector.y -= FLOATNG_GRAVITY;
             _vector.x *= FLOATING_FRICTION;
          } <span class="hljs-keyword">else</span> {
             _vector.y -= GRAVITY;
             _vector.x *= AIR_FRICTION;
             _floatingTimer = <span class="hljs-number">0</span>;
          }
          <span class="hljs-keyword">break</span>;
       <span class="hljs-keyword">case</span> kPlayerDying:
          _vector.y -= GRAVITY;
          _vector.x = -_speed;
          <span class="hljs-keyword">this</span>-&gt;setPositionX(<span class="hljs-keyword">this</span>-&gt;getPositionX() + _vector.x);
          <span class="hljs-keyword">break</span>;
    }
</code></pre><p>We have different values for gravity and friction depending on move state. We also have a time limit for how long the <code>_player</code> object can be floating, and we reset that timer when the <code>_player</code> object is not floating. If the <code>_player</code> object is dying (collided with a wall), we move the <code>_player</code> object backwards and downwards until it leaves the screen.</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;        if (_jumping) {
            _state = kPlayerFalling;
            _vector.y += PLAYER_JUMP * 0.25f;
            if (_vector.y &amp;gt; PLAYER_JUMP ) _jumping = false;
        }

        if (_vector.y &amp;lt; -TERMINAL_VELOCITY)
            _vector.y = -TERMINAL_VELOCITY;

        _nextPosition.y = this-&amp;gt;getPositionY() + _vector.y;

        if (_floating) {
            _floatingTimer += dt;
            if (_floatingTimer &amp;gt; _floatingTimerMax) {
                _floatingTimer = 0;
                this-&amp;gt;setFloating(false);
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;">        <span class="hljs-keyword">if</span> (_jumping) {
            _state = kPlayerFalling;
            _vector.y += PLAYER_JUMP * <span class="hljs-number">0.25f</span>;
            <span class="hljs-keyword">if</span> (_vector.y &gt; PLAYER_JUMP ) _jumping = <span class="hljs-keyword">false</span>;
        }

        <span class="hljs-keyword">if</span> (_vector.y &lt; -TERMINAL_VELOCITY)
            _vector.y = -TERMINAL_VELOCITY;

        _nextPosition.y = <span class="hljs-keyword">this</span>-&gt;getPositionY() + _vector.y;

        <span class="hljs-keyword">if</span> (_floating) {
            _floatingTimer += dt;
            <span class="hljs-keyword">if</span> (_floatingTimer &gt; _floatingTimerMax) {
                _floatingTimer = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">this</span>-&gt;setFloating(<span class="hljs-keyword">false</span>);
            }
        }
    }
</code></pre><p>When the player presses the screen for a jump we shouldn’t make the sprite jump immediately. Changes in state should always happen <strong>smoothly</strong>. So we have a boolean property in <code>_player</code> called <code>_jumping</code>. It is set to true when the player presses the screen and we slowly add the jump force to <code>_vector.y</code>. So the longer the player presses the screen, the higher the jump will be and a quick tap will result in a shorter jump. This is a nice feature to add to any platform game.</p><p>We next limit the y speed with a terminal velocity, update the next position of the <code>_player</code> object, and update the floating timer if <code>_player</code> is floating.</p><h4 id="行动：初始化`terrain`类"><a name="行动：初始化`terrain`类" href="#行动：初始化`terrain`类"></a>行动：初始化<code>Terrain</code>类</h4><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void Terrain::initTerrain () {
        _increaseGapInterval = 5000;
        _increaseGapTimer = 0;
        _gapSize = 2;
        _blockPool = CCArray::createWithCapacity(20);
        _blockPool-&amp;gt;retain();
        // 初始化对象池
        Block * block;
        for (int i = 0; i &amp;lt; 20; i++) {
            block = Block::create();
            this-&amp;gt;addChild(block);
            _blockPool-&amp;gt;addObject(block);
        }
        _blocks = CCArray::createWithCapacity(20);
        _blocks-&amp;gt;retain();

        _minTerrainWidth = _screenSize.width * 1.5f;
        random_shuffle(_blockPattern.begin(), _blockPattern.end());
        random_shuffle(_blockWidths.begin(), _blockWidths.end());
        random_shuffle(_blockHeights.begin(), _blockHeights.end());
        this-&amp;gt;addBlocks(0);
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> Terrain::initTerrain () {
        _increaseGapInterval = <span class="hljs-number">5000</span>;
        _increaseGapTimer = <span class="hljs-number">0</span>;
        _gapSize = <span class="hljs-number">2</span>;
        _blockPool = CCArray::createWithCapacity(<span class="hljs-number">20</span>);
        _blockPool-&gt;retain();
        <span class="hljs-comment">// 初始化对象池</span>
        Block * block;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) {
            block = Block::create();
            <span class="hljs-keyword">this</span>-&gt;addChild(block);
            _blockPool-&gt;addObject(block);
        }
        _blocks = CCArray::createWithCapacity(<span class="hljs-number">20</span>);
        _blocks-&gt;retain();

        _minTerrainWidth = _screenSize.width * <span class="hljs-number">1.5f</span>;
        random_shuffle(_blockPattern.begin(), _blockPattern.end());
        random_shuffle(_blockWidths.begin(), _blockWidths.end());
        random_shuffle(_blockHeights.begin(), _blockHeights.end());
        <span class="hljs-keyword">this</span>-&gt;addBlocks(<span class="hljs-number">0</span>);
    }
</code></pre><p>We have a timer to increase the width of gaps (we begin with gaps two tiles long).</p><p>创建一个block的对象池。于是在游戏过程中再实例化。20足够多了。<code>_terrain</code>对象的最小宽度是屏幕宽度的1.5倍。</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void Terrain::addBlocks(int currentWidth) {
        Block * block;
        while (currentWidth &amp;lt; _minTerrainWidth) {
            block = (Block *) _blockPool-&amp;gt;objectAtIndex(_blockPoolIndex);
            _blockPoolIndex++;
            if (_blockPoolIndex == _blockPool-&amp;gt;count()) {
                _blockPoolIndex = 0;
          }
          this-&amp;gt;initBlock(block);
          currentWidth += block-&amp;gt;getWidth();
          _blocks-&amp;gt;addObject(block);
       }
       this-&amp;gt;distributeBlocks();
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> Terrain::addBlocks(<span class="hljs-keyword">int</span> currentWidth) {
        Block * block;
        <span class="hljs-keyword">while</span> (currentWidth &lt; _minTerrainWidth) {
            block = (Block *) _blockPool-&gt;objectAtIndex(_blockPoolIndex);
            _blockPoolIndex++;
            <span class="hljs-keyword">if</span> (_blockPoolIndex == _blockPool-&gt;count()) {
                _blockPoolIndex = <span class="hljs-number">0</span>;
          }
          <span class="hljs-keyword">this</span>-&gt;initBlock(block);
          currentWidth += block-&gt;getWidth();
          _blocks-&gt;addObject(block);
       }
       <span class="hljs-keyword">this</span>-&gt;distributeBlocks();
    }
</code></pre><p>反复增加block直到<code>_terrain</code>对象的宽度超过最小宽度。</p><p>放置块：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void Terrain::distributeBlocks() {
        int count = _blocks-&amp;gt;count();

        Block * block;
        Block * prev_block;
        for (int i = 0; i &amp;lt; count; i++) {
            block = (Block *) _blocks-&amp;gt;objectAtIndex(i);
            if (i != 0) {
                prev_block = (Block *) _blocks-&amp;gt;objectAtIndex(i - 1);
                block-&amp;gt;setPositionX( prev_block-&amp;gt;getPositionX()
                    + prev_block-&amp;gt;getWidth());
            } else {
                block-&amp;gt;setPositionX ( 0 );
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> Terrain::distributeBlocks() {
        <span class="hljs-keyword">int</span> count = _blocks-&gt;count();

        Block * block;
        Block * prev_block;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
            block = (Block *) _blocks-&gt;objectAtIndex(i);
            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) {
                prev_block = (Block *) _blocks-&gt;objectAtIndex(i - <span class="hljs-number">1</span>);
                block-&gt;setPositionX( prev_block-&gt;getPositionX()
                    + prev_block-&gt;getWidth());
            } <span class="hljs-keyword">else</span> {
                block-&gt;setPositionX ( <span class="hljs-number">0</span> );
            }
        }
    }
</code></pre><h4 id="行动：初始化blocks"><a name="行动：初始化blocks" href="#行动：初始化blocks"></a>行动：初始化Blocks</h4><p>Finally the method that initializes the blocks based on our <code>patterns</code> array.</p><p>Inside the <code>Terrain</code> class, we start the <code>initBlock</code> method like this:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void Terrain::initBlock(Block * block) {
        int blockWidth;
        int blockHeight;
        int type = _blockTypes[_currentTypeIndex];
        _currentTypeIndex++;
        if (_currentTypeIndex == _blockTypes.size()) {
            _currentTypeIndex = 0;
        }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> Terrain::initBlock(Block * block) {
        <span class="hljs-keyword">int</span> blockWidth;
        <span class="hljs-keyword">int</span> blockHeight;
        <span class="hljs-keyword">int</span> type = _blockTypes[_currentTypeIndex];
        _currentTypeIndex++;
        <span class="hljs-keyword">if</span> (_currentTypeIndex == _blockTypes.size()) {
            _currentTypeIndex = <span class="hljs-number">0</span>;
        }
</code></pre><p>开始构建块：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;        if (_startTerrain) {
            //...
        } else {
            _lastBlockHeight = 2; // 2个瓷砖高
            _lastBlockWidth = rand() % 2 + 2;
            block-&amp;gt;setupBlock (_lastBlockWidth, _lastBlockHeight, type);
        }
`
&lt;/code&gt;&lt;/pre&gt;">        <span class="hljs-keyword">if</span> (_startTerrain) {
            <span class="hljs-comment">//...</span>
        } <span class="hljs-keyword">else</span> {
            _lastBlockHeight = <span class="hljs-number">2</span>; <span class="hljs-comment">// 2个瓷砖高</span>
            _lastBlockWidth = rand() % <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;
            block-&gt;setupBlock (_lastBlockWidth, _lastBlockHeight, type);
        }
`
</code></pre><p>The player must tap the screen to begin the game (<code>_startTerrain</code>), until then we show buildings with the same height (two <strong>tiles</strong>) and random width.</p><p>If we are set to <code>_startTerrain</code>:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;        if (_startTerrain) {
            if (_showGap) {
                int gap = rand() % _gapSize;
                if (gap &amp;lt; 2) gap = 2;
                block-&amp;gt;setupBlock (gap, 0, kBlockGap);
                _showGap = false;
        } else {
            //...
&lt;/code&gt;&lt;/pre&gt;">        <span class="hljs-keyword">if</span> (_startTerrain) {
            <span class="hljs-keyword">if</span> (_showGap) {
                <span class="hljs-keyword">int</span> gap = rand() % _gapSize;
                <span class="hljs-keyword">if</span> (gap &lt; <span class="hljs-number">2</span>) gap = <span class="hljs-number">2</span>;
                block-&gt;setupBlock (gap, <span class="hljs-number">0</span>, kBlockGap);
                _showGap = <span class="hljs-keyword">false</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">//...</span>
</code></pre><p>The information inside <code>_blockPattern</code> determines how many buildings we show in a row, and once a series is completed we show a gap by setting the boolean value of <code>_showGap</code> to true. A gap’s width is based on the current value of <code>_gapSize</code>, which may increase as the game gets harder and it can’t be less than two times the tile width.</p><p>If we are not creating a gap this time:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    } else {
        blockWidth = _blockWidths[_currentWidthIndex];
        _currentWidthIndex++;
        if (_currentWidthIndex == _blockWidths.size()) {
            random_shuffle(_blockWidths.begin(), _blockWidths.end());
            _currentWidthIndex = 0;
        }
        if (_blockHeights[_currentHeightIndex] != 0) {
            // change height of next block
            blockHeight = _blockHeights[_currentHeightIndex];
            // if difference too high, decrease it
            if (blockHeight - _lastBlockHeight &amp;gt; 2 
                &amp;amp;&amp;amp; _gapSize == 2) {
                blockHeight = 1;
            }
        } else {
            blockHeight = _lastBlockHeight;
        }
        _currentHeightIndex++;
        if (_currentHeightIndex == _blockHeights.size()) {
            _currentHeightIndex = 0;
            random_shuffle(_blockHeights.begin(), _blockHeights.end());
        }
        block-&amp;gt;setupBlock (blockWidth, blockHeight, type);
        _lastBlockWidth = blockWidth;
        _lastBlockHeight = blockHeight;
&lt;/code&gt;&lt;/pre&gt;">    } <span class="hljs-keyword">else</span> {
        blockWidth = _blockWidths[_currentWidthIndex];
        _currentWidthIndex++;
        <span class="hljs-keyword">if</span> (_currentWidthIndex == _blockWidths.size()) {
            random_shuffle(_blockWidths.begin(), _blockWidths.end());
            _currentWidthIndex = <span class="hljs-number">0</span>;
        }
        <span class="hljs-keyword">if</span> (_blockHeights[_currentHeightIndex] != <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// change height of next block</span>
            blockHeight = _blockHeights[_currentHeightIndex];
            <span class="hljs-comment">// if difference too high, decrease it</span>
            <span class="hljs-keyword">if</span> (blockHeight - _lastBlockHeight &gt; <span class="hljs-number">2</span> 
                &amp;&amp; _gapSize == <span class="hljs-number">2</span>) {
                blockHeight = <span class="hljs-number">1</span>;
            }
        } <span class="hljs-keyword">else</span> {
            blockHeight = _lastBlockHeight;
        }
        _currentHeightIndex++;
        <span class="hljs-keyword">if</span> (_currentHeightIndex == _blockHeights.size()) {
            _currentHeightIndex = <span class="hljs-number">0</span>;
            random_shuffle(_blockHeights.begin(), _blockHeights.end());
        }
        block-&gt;setupBlock (blockWidth, blockHeight, type);
        _lastBlockWidth = blockWidth;
        _lastBlockHeight = blockHeight;
</code></pre><p>We determine the width and height of the new block based on the current indexed values of <code>_blockWidths</code> and <code>_blockHeights</code>. Notice how we reshuffle the arrays once we are done iterating through them (<code>random_shuffle</code>).</p><p>We finish by updating the count in the current series of buildings, to determine if we should show a gap next, or not:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    //select next block series pattern
    _currentPatternCnt++;
    if (_currentPatternCnt &amp;gt; _blockPattern[_currentPatternIndex]) {
        _showGap = true;
        //start new pattern
        _currentPatternIndex++;
        if (_currentPatternIndex == _blockPattern.size()) {
            random_shuffle(_blockPattern.begin(),
                _blockPattern.end());
            _currentPatternIndex = 0;
        }
        _currentPatternCnt = 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-comment">//select next block series pattern</span>
    _currentPatternCnt++;
    <span class="hljs-keyword">if</span> (_currentPatternCnt &gt; _blockPattern[_currentPatternIndex]) {
        _showGap = <span class="hljs-keyword">true</span>;
        <span class="hljs-comment">//start new pattern</span>
        _currentPatternIndex++;
        <span class="hljs-keyword">if</span> (_currentPatternIndex == _blockPattern.size()) {
            random_shuffle(_blockPattern.begin(),
                _blockPattern.end());
            _currentPatternIndex = <span class="hljs-number">0</span>;
        }
        _currentPatternCnt = <span class="hljs-number">1</span>;
    }
}
</code></pre><h4 id="行动：移动和重置"><a name="行动：移动和重置" href="#行动：移动和重置"></a>行动：移动和重置</h4><p>We move the terrain inside the <code>move</code> method:</p><p><code>xMove</code>表示在x轴移动的距离。其值取决于<code>_player</code>的速度。</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void Terrain::move (float xMove) {
        if (xMove &amp;lt; 0) return;
        if (_startTerrain) {
            if (xMove &amp;gt; 0 &amp;amp;&amp;amp; _gapSize &amp;lt; 5)
                _increaseGapTimer += xMove;
            if (_increaseGapTimer &amp;gt; _increaseGapInterval) {
                _increaseGapTimer = 0;
                _gapSize += 1;
            }
        }
        this-&amp;gt;setPositionX(this-&amp;gt;getPositionX() - xMove);
        Block * block;
        block = (Block *) _blocks-&amp;gt;objectAtIndex(0);
        if (m_tPosition.x + block-&amp;gt;getWidth() &amp;lt; 0) {
            _blocks-&amp;gt;removeObjectAtIndex(0);
            _blocks-&amp;gt;addObject(block);
            m_tPosition.x += block-&amp;gt;getWidth();
            float width_cnt = this-&amp;gt;getWidth() - block-&amp;gt;getWidth()
                - ((Block *) _blocks-&amp;gt;objectAtIndex(0))-&amp;gt; getWidth();
            this-&amp;gt;initBlock(block);
            this-&amp;gt;addBlocks(width_cnt);
        }
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> Terrain::move (<span class="hljs-keyword">float</span> xMove) {
        <span class="hljs-keyword">if</span> (xMove &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span> (_startTerrain) {
            <span class="hljs-keyword">if</span> (xMove &gt; <span class="hljs-number">0</span> &amp;&amp; _gapSize &lt; <span class="hljs-number">5</span>)
                _increaseGapTimer += xMove;
            <span class="hljs-keyword">if</span> (_increaseGapTimer &gt; _increaseGapInterval) {
                _increaseGapTimer = <span class="hljs-number">0</span>;
                _gapSize += <span class="hljs-number">1</span>;
            }
        }
        <span class="hljs-keyword">this</span>-&gt;setPositionX(<span class="hljs-keyword">this</span>-&gt;getPositionX() - xMove);
        Block * block;
        block = (Block *) _blocks-&gt;objectAtIndex(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">if</span> (m_tPosition.x + block-&gt;getWidth() &lt; <span class="hljs-number">0</span>) {
            _blocks-&gt;removeObjectAtIndex(<span class="hljs-number">0</span>);
            _blocks-&gt;addObject(block);
            m_tPosition.x += block-&gt;getWidth();
            <span class="hljs-keyword">float</span> width_cnt = <span class="hljs-keyword">this</span>-&gt;getWidth() - block-&gt;getWidth()
                - ((Block *) _blocks-&gt;objectAtIndex(<span class="hljs-number">0</span>))-&gt; getWidth();
            <span class="hljs-keyword">this</span>-&gt;initBlock(block);
            <span class="hljs-keyword">this</span>-&gt;addBlocks(width_cnt);
        }
    }
</code></pre><p>定时器用于增大间隙。然后我们将terrain向左移动。如果移动后，一个块移出了屏幕，则将它移到<code>_blocks</code>最后，将其初始化一个新的块（<code>initBlock</code>）。</p><p>最后调用<code>addBlocks</code>确保terrain超过最小要求的长度。</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void Terrain::reset() {
        this-&amp;gt;setPosition(ccp(0,0));
        _startTerrain = false;
        int count = _blocks-&amp;gt;count();
        Block * block;
        int currentWidth = 0;
        for (int i = 0; i &amp;lt; count; i++) {
            block = (Block *) _blocks-&amp;gt;objectAtIndex(i);
            this-&amp;gt;initBlock(block);
            currentWidth += block-&amp;gt;getWidth();
        }
        while (currentWidth &amp;lt; _minTerrainWidth) {
            block = (Block *) _blockPool-&amp;gt;objectAtIndex(_blockPoolIndex);
            _blockPoolIndex++;
            if (_blockPoolIndex == _blockPool-&amp;gt;count()) {
                _blockPoolIndex = 0;
            }
            _blocks-&amp;gt;addObject(block);
            this-&amp;gt;initBlock(block);
            currentWidth += block-&amp;gt;getWidth();
        }
        this-&amp;gt;distributeBlocks();
        _increaseGapTimer = 0;
        _gapSize = 2;
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> Terrain::reset() {
        <span class="hljs-keyword">this</span>-&gt;setPosition(ccp(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>));
        _startTerrain = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">int</span> count = _blocks-&gt;count();
        Block * block;
        <span class="hljs-keyword">int</span> currentWidth = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
            block = (Block *) _blocks-&gt;objectAtIndex(i);
            <span class="hljs-keyword">this</span>-&gt;initBlock(block);
            currentWidth += block-&gt;getWidth();
        }
        <span class="hljs-keyword">while</span> (currentWidth &lt; _minTerrainWidth) {
            block = (Block *) _blockPool-&gt;objectAtIndex(_blockPoolIndex);
            _blockPoolIndex++;
            <span class="hljs-keyword">if</span> (_blockPoolIndex == _blockPool-&gt;count()) {
                _blockPoolIndex = <span class="hljs-number">0</span>;
            }
            _blocks-&gt;addObject(block);
            <span class="hljs-keyword">this</span>-&gt;initBlock(block);
            currentWidth += block-&gt;getWidth();
        }
        <span class="hljs-keyword">this</span>-&gt;distributeBlocks();
        _increaseGapTimer = <span class="hljs-number">0</span>;
        _gapSize = <span class="hljs-number">2</span>;
    }
</code></pre><h3 id="平台碰撞检测逻辑"><a name="平台碰撞检测逻辑" href="#平台碰撞检测逻辑"></a>平台碰撞检测逻辑</h3><p>In this game we’ll need to check collision between the _player’s bottom side and the Block’s top side, and between the _player’s right side and the Block’s left side. We’ll do that by checking the _player’s current and next position.</p><p>Still in <code>Terrain.cpp</code>:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void Terrain::checkCollision (Player * player) {
        if (player-&amp;gt;getState() == kPlayerDying) return;
        int count = _blocks-&amp;gt;count();
        Block * block;
        bool inAir = true;
        for (int i = 0; i &amp;lt; count; i++) {
            block = (Block *) _blocks-&amp;gt;objectAtIndex(i);
            if (block-&amp;gt;getType() == kBlockGap) continue;
            // if within x range, check y (bottom collision)
            if (player-&amp;gt;right() &amp;gt;= this-&amp;gt;getPositionX() + block-&amp;gt;left()
                &amp;amp;&amp;amp; player-&amp;gt;left() &amp;lt;= this-&amp;gt;getPositionX() + block-&amp;gt;right()) {
                if (player-&amp;gt;bottom() &amp;gt;= block-&amp;gt;top()
                    &amp;amp;&amp;amp; player-&amp;gt;next_bottom() &amp;lt;= block-&amp;gt;top()
                    &amp;amp;&amp;amp; player-&amp;gt;top() &amp;gt; block-&amp;gt;top()) {
                    player-&amp;gt;setNextPosition(ccp(player-&amp;gt;getNextPosition().x,
                        block-&amp;gt;top() + player-&amp;gt;getHeight()));
                    player-&amp;gt;setVector ( ccp(player-&amp;gt;getVector().x, 0));
                    inAir = false;
                    break;
                }
            }
        }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> Terrain::checkCollision (Player * player) {
        <span class="hljs-keyword">if</span> (player-&gt;getState() == kPlayerDying) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">int</span> count = _blocks-&gt;count();
        Block * block;
        <span class="hljs-keyword">bool</span> inAir = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
            block = (Block *) _blocks-&gt;objectAtIndex(i);
            <span class="hljs-keyword">if</span> (block-&gt;getType() == kBlockGap) <span class="hljs-keyword">continue</span>;
            <span class="hljs-comment">// if within x range, check y (bottom collision)</span>
            <span class="hljs-keyword">if</span> (player-&gt;right() &gt;= <span class="hljs-keyword">this</span>-&gt;getPositionX() + block-&gt;left()
                &amp;&amp; player-&gt;left() &lt;= <span class="hljs-keyword">this</span>-&gt;getPositionX() + block-&gt;right()) {
                <span class="hljs-keyword">if</span> (player-&gt;bottom() &gt;= block-&gt;top()
                    &amp;&amp; player-&gt;next_bottom() &lt;= block-&gt;top()
                    &amp;&amp; player-&gt;top() &gt; block-&gt;top()) {
                    player-&gt;setNextPosition(ccp(player-&gt;getNextPosition().x,
                        block-&gt;top() + player-&gt;getHeight()));
                    player-&gt;setVector ( ccp(player-&gt;getVector().x, <span class="hljs-number">0</span>));
                    inAir = <span class="hljs-keyword">false</span>;
                    <span class="hljs-keyword">break</span>;
                }
            }
        }
</code></pre><p>First we state that the _playerobject is currently falling with inAir = true. We don’t check for collisions if _playeris dying and we skip collision checks with any gap blocks. 设为<code>inAir = false</code>表示玩家已着陆。</p><p>下面检查x轴方向的碰撞：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    for (int i = 0; i &amp;lt; count; i++) {
        block = (Block *) _blocks-&amp;gt;objectAtIndex(i);
        if (block-&amp;gt;getType() == kBlockGap) continue;
        // now if within y range, check x (side collision)
        if ((player-&amp;gt;bottom() &amp;lt; block-&amp;gt;top()
            &amp;amp;&amp;amp; player-&amp;gt;top() &amp;gt; block-&amp;gt;bottom())
            || (player-&amp;gt;next_bottom() &amp;lt; block-&amp;gt;top()
            &amp;amp;&amp;amp; player-&amp;gt;next_top() &amp;gt; block-&amp;gt;bottom())) {
            if (player-&amp;gt;right() &amp;gt;= this-&amp;gt;getPositionX() + block-&amp;gt;getPositionX()
                &amp;amp;&amp;amp; player-&amp;gt;left() &amp;lt; this-&amp;gt;getPositionX() + block-&amp;gt;getPositionX()) {
            player-&amp;gt;setPositionX( this-&amp;gt;getPositionX() + block-&amp;gt;getPositionX() - player-&amp;gt;getWidth() * 0.5f );
            player-&amp;gt;setNextPosition(ccp(this-&amp;gt;getPositionX() + block-&amp;gt;getPositionX() - player-&amp;gt;getWidth() * 0.5f, player-&amp;gt;getNextPosition().y));
            player-&amp;gt;setVector(ccp(player-&amp;gt;getVector().x * -0.5f, player-&amp;gt;getVector().y) );
            if (player-&amp;gt;bottom() + player-&amp;gt;getHeight() * 0.2f &amp;lt; block-&amp;gt;top()) {
                player-&amp;gt;setState(sprite);
                return;
            }
            break;
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
        block = (Block *) _blocks-&gt;objectAtIndex(i);
        <span class="hljs-keyword">if</span> (block-&gt;getType() == kBlockGap) <span class="hljs-keyword">continue</span>;
        <span class="hljs-comment">// now if within y range, check x (side collision)</span>
        <span class="hljs-keyword">if</span> ((player-&gt;bottom() &lt; block-&gt;top()
            &amp;&amp; player-&gt;top() &gt; block-&gt;bottom())
            || (player-&gt;next_bottom() &lt; block-&gt;top()
            &amp;&amp; player-&gt;next_top() &gt; block-&gt;bottom())) {
            <span class="hljs-keyword">if</span> (player-&gt;right() &gt;= <span class="hljs-keyword">this</span>-&gt;getPositionX() + block-&gt;getPositionX()
                &amp;&amp; player-&gt;left() &lt; <span class="hljs-keyword">this</span>-&gt;getPositionX() + block-&gt;getPositionX()) {
            player-&gt;setPositionX( <span class="hljs-keyword">this</span>-&gt;getPositionX() + block-&gt;getPositionX() - player-&gt;getWidth() * <span class="hljs-number">0.5f</span> );
            player-&gt;setNextPosition(ccp(<span class="hljs-keyword">this</span>-&gt;getPositionX() + block-&gt;getPositionX() - player-&gt;getWidth() * <span class="hljs-number">0.5f</span>, player-&gt;getNextPosition().y));
            player-&gt;setVector(ccp(player-&gt;getVector().x * -<span class="hljs-number">0.5f</span>, player-&gt;getVector().y) );
            <span class="hljs-keyword">if</span> (player-&gt;bottom() + player-&gt;getHeight() * <span class="hljs-number">0.2f</span> &lt; block-&gt;top()) {
                player-&gt;setState(sprite);
                <span class="hljs-keyword">return</span>;
            }
            <span class="hljs-keyword">break</span>;
            }
        }
    }
</code></pre><p>We end by updating the <code>_player</code>‘s state based on our collision results:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;        if (inAir) {
            player-&amp;gt;setState(kPlayerFalling);
        } else {
            player-&amp;gt;setState(kPlayerMoving);
            player-&amp;gt;setFloating (false);
        }
    }
&lt;/code&gt;&lt;/pre&gt;">        <span class="hljs-keyword">if</span> (inAir) {
            player-&gt;setState(kPlayerFalling);
        } <span class="hljs-keyword">else</span> {
            player-&gt;setState(kPlayerMoving);
            player-&gt;setFloating (<span class="hljs-keyword">false</span>);
        }
    }
</code></pre><h3 id="添加控制"><a name="添加控制" href="#添加控制"></a>添加控制</h3><p>Remember, we want smooth transitions between states, so pay attention to how jumping<br>is implemented: not by immediately applying a force to the player’s vector, but by simply<br>changing a booleanproperty and letting the _player’s updatemethod handle the<br>change smoothly.</p><h4 id="行动：处理触摸"><a name="行动：处理触摸" href="#行动：处理触摸"></a>行动：处理触摸</h4><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void GameLayer::ccTouchesBegan(CCSet* pTouches, CCEvent* event) {
        if (!_running) {
            if (_player-&amp;gt;getState() == kPlayerDying) {
                _terrain-&amp;gt;reset();
                _player-&amp;gt;reset();
                resetGame();
            }
            return;
        }

        if (!_terrain-&amp;gt;getStartTerrain()) {
        _terrain-&amp;gt;setStartTerrain ( true );
            return;
        }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> GameLayer::ccTouchesBegan(CCSet* pTouches, CCEvent* event) {
        <span class="hljs-keyword">if</span> (!_running) {
            <span class="hljs-keyword">if</span> (_player-&gt;getState() == kPlayerDying) {
                _terrain-&gt;reset();
                _player-&gt;reset();
                resetGame();
            }
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">if</span> (!_terrain-&gt;getStartTerrain()) {
        _terrain-&gt;setStartTerrain ( <span class="hljs-keyword">true</span> );
            <span class="hljs-keyword">return</span>;
        }
</code></pre><p>Remember that at first the buildings are all the same height and there are no gaps. Once the player presses the screen, we begin changing that through <code>setStartTerrain</code>.</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;        CCTouch *touch = (CCTouch *)pTouches-&amp;gt;anyObject();
        if (touch) {
            if (_player-&amp;gt;getState() == kPlayerFalling) {
                _player-&amp;gt;setFloating ( _player-&amp;gt;getFloating()?false : true );
            } else {
                if (_player-&amp;gt;getState() != kPlayerDying)
                    _player-&amp;gt;setJumping(true);
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;">        CCTouch *touch = (CCTouch *)pTouches-&gt;anyObject();
        <span class="hljs-keyword">if</span> (touch) {
            <span class="hljs-keyword">if</span> (_player-&gt;getState() == kPlayerFalling) {
                _player-&gt;setFloating ( _player-&gt;getFloating()?<span class="hljs-keyword">false</span> : <span class="hljs-keyword">true</span> );
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (_player-&gt;getState() != kPlayerDying)
                    _player-&gt;setJumping(<span class="hljs-keyword">true</span>);
            }
        }
    }
</code></pre><p>If a touch ends, we just need to stop any jumps:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void GameLayer::ccTouchesEnded(CCSet* pTouches, CCEvent* event) {
        _player-&amp;gt;setJumping(false);
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> GameLayer::ccTouchesEnded(CCSet* pTouches, CCEvent* event) {
        _player-&gt;setJumping(<span class="hljs-keyword">false</span>);
    }
</code></pre><h4 id="行动：主循环"><a name="行动：主循环" href="#行动：主循环"></a>行动：主循环</h4><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void GameLayer::update(float dt) {
        if (!_running) return;
        if (_player-&amp;gt;getPositionY() &amp;lt; -_player-&amp;gt;getHeight()
            || _player-&amp;gt;getPositionX() &amp;lt; -_player-&amp;gt;getWidth() * 0.5f)
            {
            _running = false;
        }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> GameLayer::update(<span class="hljs-keyword">float</span> dt) {
        <span class="hljs-keyword">if</span> (!_running) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span> (_player-&gt;getPositionY() &lt; -_player-&gt;getHeight()
            || _player-&gt;getPositionX() &lt; -_player-&gt;getWidth() * <span class="hljs-number">0.5f</span>)
            {
            _running = <span class="hljs-keyword">false</span>;
        }
</code></pre><p>Now update all the elements positions and check for collision:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;        _player-&amp;gt;update(dt);
        _terrain-&amp;gt;move(_player-&amp;gt;getVector().x);
        if (_player-&amp;gt;getState() != kPlayerDying)
            _terrain-&amp;gt;checkCollision(_player);
        _player-&amp;gt;place();
&lt;/code&gt;&lt;/pre&gt;">        _player-&gt;update(dt);
        _terrain-&gt;move(_player-&gt;getVector().x);
        <span class="hljs-keyword">if</span> (_player-&gt;getState() != kPlayerDying)
            _terrain-&gt;checkCollision(_player);
        _player-&gt;place();
</code></pre><p>Move <code>_gameBatchNode</code> in relation to the <code>_player</code> object:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;        if (_player-&amp;gt;getNextPosition().y &amp;gt; _screenSize.height * 0.6f) {
            _gameBatchNode-&amp;gt;setPositionY( (_screenSize.height * 0.6f - _player-&amp;gt;getNextPosition().y) * 0.8f);
        } else {
            _gameBatchNode-&amp;gt;setPositionY ( 0 );
        }
&lt;/code&gt;&lt;/pre&gt;">        <span class="hljs-keyword">if</span> (_player-&gt;getNextPosition().y &gt; _screenSize.height * <span class="hljs-number">0.6f</span>) {
            _gameBatchNode-&gt;setPositionY( (_screenSize.height * <span class="hljs-number">0.6f</span> - _player-&gt;getNextPosition().y) * <span class="hljs-number">0.8f</span>);
        } <span class="hljs-keyword">else</span> {
            _gameBatchNode-&gt;setPositionY ( <span class="hljs-number">0</span> );
        }
</code></pre><p>And make the game more difficult as time goes on by increasing the _player’s maximum speed:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;        if (_terrain-&amp;gt;getStartTerrain() &amp;amp;&amp;amp; _player-&amp;gt;getVector().x &amp;gt; 0) {
            _speedIncreaseTimer += dt;
            if (_speedIncreaseTimer &amp;gt; _speedIncreaseInterval) {
                _speedIncreaseTimer = 0;
                _player-&amp;gt;setMaxSpeed (_player-&amp;gt;getMaxSpeed() + 4);
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;">        <span class="hljs-keyword">if</span> (_terrain-&gt;getStartTerrain() &amp;&amp; _player-&gt;getVector().x &gt; <span class="hljs-number">0</span>) {
            _speedIncreaseTimer += dt;
            <span class="hljs-keyword">if</span> (_speedIncreaseTimer &gt; _speedIncreaseInterval) {
                _speedIncreaseTimer = <span class="hljs-number">0</span>;
                _player-&gt;setMaxSpeed (_player-&gt;getMaxSpeed() + <span class="hljs-number">4</span>);
            }
        }
    }
</code></pre><h2 id="7-向victorian-rush-hour添加外观"><a name="7-向victorian-rush-hour添加外观" href="#7-向victorian-rush-hour添加外观"></a>7 向Victorian Rush Hour添加外观</h2><p>本章内容：</p><ul>
<li>How to use multiple sprites to texture a tiled terrain</li>
<li>How to use multiple containers inside a <code>CCSpriteBatchNode</code></li>
<li>How to create a parallax effect</li>
<li>如何向游戏添加菜单</li>
<li>How to build a game tutorial</li>
</ul><h3 id="victorian-rush-hour-–-the-game"><a name="victorian-rush-hour-–-the-game" href="#victorian-rush-hour-–-the-game"></a>Victorian Rush Hour – the game</h3><p><img src="game-ch7.png" alt=""></p><h4 id="新精灵"><a name="新精灵" href="#新精灵"></a>新精灵</h4><ul>
<li>There is a group of cyclists at the beginning of the game representing the rush traffic.</li>
<li>We add a background layer (cityscape) and a foreground layer (lampposts) to help us with our parallax effect. The clouds in the background are also part of the effect.</li>
<li>We add chimneys to the buildings. These puff smoke as the player taps the screen.</li>
<li>And of course the usual stuff: score label, game logo, and a game over message.</li>
</ul><p><img src="sprits-ch7.png" alt=""></p><h4 id="动画"><a name="动画" href="#动画"></a>动画</h4><p><code>_player</code>运行动画<code>_rideAnimation</code>，展示它在骑自行车。 Also added was our old friend, the swinging animation, shown when the <code>_player</code> is floating (<code>_floatAnimation</code>). This is the reason for the odd registration point on the cyclist sprite, as the swing animation looks better if the sprite’s anchor point is not centered. Our group of cyclists are also animated during the intro section of the game, and are moved offscreen when the game starts (<code>_jamAnimate</code>, <code>_jamMove</code>).</p><p>We show a puff of smoke coming out of the chimneys whenever the player jumps. This animation is stored inside the new <code>Block.cpp</code> class and is created through a series of actions, including a frame animation (_puffAnimation, _puffSpawn, _puffMove, _puffFade, and _puffScale). In <code>GameLayer.cpp</code>, when the _player dies, we run a few actions on a <code>_hat</code> sprite to make it rise in the air and drop down again, just to add some humor.</p><h3 id="使用`ccsprite`给动画添加纹理"><a name="使用`ccsprite`给动画添加纹理" href="#使用`ccsprite`给动画添加纹理"></a>使用<code>CCSprite</code>给动画添加纹理</h3><p>在上一章的工程中，我们将游戏屏划分为128像素的一个瓷砖（iPad retina屏）。The width and height properties of the <code>Block</code> objects are based on this measurement. So a building two tiles wide, and three tiles tall would have in effect 256 pixels in width and 384 pixels in height. A gap too would be measured this way, though its height is set to 0.</p><p>The logic we use to texture the buildings will take these tiles into account.</p><p><img src="ch7-buildings.png" alt=""></p><p>四种不同的建筑(_tile1, _tile2, _tile3, and _tile4)。</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void Block::initBlock() {
        _tile1 = CCSpriteFrameCache::sharedSpriteFrameCache()
            -&amp;gt;spriteFrameByName (&quot;building_1.png&quot;);
        _tile2 = CCSpriteFrameCache::sharedSpriteFrameCache()
            -&amp;gt;spriteFrameByName (&quot;building_2.png&quot;);
        _tile3 = CCSpriteFrameCache::sharedSpriteFrameCache()
            -&amp;gt;spriteFrameByName (&quot;building_3.png&quot;);
        _tile4 = CCSpriteFrameCache::sharedSpriteFrameCache()
            -&amp;gt;spriteFrameByName (&quot;building_4.png&quot;);
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> Block::initBlock() {
        _tile1 = CCSpriteFrameCache::sharedSpriteFrameCache()
            -&gt;spriteFrameByName (<span class="hljs-string">"building_1.png"</span>);
        _tile2 = CCSpriteFrameCache::sharedSpriteFrameCache()
            -&gt;spriteFrameByName (<span class="hljs-string">"building_2.png"</span>);
        _tile3 = CCSpriteFrameCache::sharedSpriteFrameCache()
            -&gt;spriteFrameByName (<span class="hljs-string">"building_3.png"</span>);
        _tile4 = CCSpriteFrameCache::sharedSpriteFrameCache()
            -&gt;spriteFrameByName (<span class="hljs-string">"building_4.png"</span>);
</code></pre><p>两种屋顶的贴图(_roof1 and _roof2)：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;        _roof1 = CCSpriteFrameCache::sharedSpriteFrameCache()
            -&amp;gt;spriteFrameByName (&quot;roof_1.png&quot;);
        _roof2 = CCSpriteFrameCache::sharedSpriteFrameCache()
            -&amp;gt;spriteFrameByName (&quot;roof_2.png&quot;);
&lt;/code&gt;&lt;/pre&gt;">        _roof1 = CCSpriteFrameCache::sharedSpriteFrameCache()
            -&gt;spriteFrameByName (<span class="hljs-string">"roof_1.png"</span>);
        _roof2 = CCSpriteFrameCache::sharedSpriteFrameCache()
            -&gt;spriteFrameByName (<span class="hljs-string">"roof_2.png"</span>);
</code></pre><p>Next we create and distribute the various CCSprite tiles that form our building:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;        // create tiles
        int i;
        _wallTiles = CCArray::createWithCapacity(20);
        _wallTiles-&amp;gt;retain();
        _roofTiles = CCArray::createWithCapacity(5);
        _roofTiles-&amp;gt;retain();
        CCSprite * tile;
        // place CCSprite tiles （每个建筑物5列4行）
        for (i = 0; i &amp;lt; 5; i++) {
            tile = CCSprite::createWithSpriteFrameName(&quot;roof_1.png&quot;);
            tile-&amp;gt;setAnchorPoint(ccp(0, 1));
            tile-&amp;gt;setPosition(ccp(i * _tileWidth, 0));
            tile-&amp;gt;setVisible(false);
            this-&amp;gt;addChild(tile, kMiddleground, kRoofTile);
            _roofTiles-&amp;gt;addObject(tile);
            for (int j = 0; j &amp;lt; 4; j++) {
                tile = CCSprite::createWithSpriteFrameName
                (&quot;building_1.png&quot;);
                tile-&amp;gt;setAnchorPoint(ccp(0, 1));
                tile-&amp;gt;setPosition(ccp(i * _tileWidth, -1 * (_tileHeight * 0.47f + j * _tileHeight)));
                tile-&amp;gt;setVisible(false);
                this-&amp;gt;addChild(tile, kBackground, kWallTile);
                _wallTiles-&amp;gt;addObject(tile);
            }
        }
&lt;/code&gt;&lt;/pre&gt;">        <span class="hljs-comment">// create tiles</span>
        <span class="hljs-keyword">int</span> i;
        _wallTiles = CCArray::createWithCapacity(<span class="hljs-number">20</span>);
        _wallTiles-&gt;retain();
        _roofTiles = CCArray::createWithCapacity(<span class="hljs-number">5</span>);
        _roofTiles-&gt;retain();
        CCSprite * tile;
        <span class="hljs-comment">// place CCSprite tiles （每个建筑物5列4行）</span>
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) {
            tile = CCSprite::createWithSpriteFrameName(<span class="hljs-string">"roof_1.png"</span>);
            tile-&gt;setAnchorPoint(ccp(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));
            tile-&gt;setPosition(ccp(i * _tileWidth, <span class="hljs-number">0</span>));
            tile-&gt;setVisible(<span class="hljs-keyword">false</span>);
            <span class="hljs-keyword">this</span>-&gt;addChild(tile, kMiddleground, kRoofTile);
            _roofTiles-&gt;addObject(tile);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++) {
                tile = CCSprite::createWithSpriteFrameName
                (<span class="hljs-string">"building_1.png"</span>);
                tile-&gt;setAnchorPoint(ccp(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));
                tile-&gt;setPosition(ccp(i * _tileWidth, -<span class="hljs-number">1</span> * (_tileHeight * <span class="hljs-number">0.47f</span> + j * _tileHeight)));
                tile-&gt;setVisible(<span class="hljs-keyword">false</span>);
                <span class="hljs-keyword">this</span>-&gt;addChild(tile, kBackground, kWallTile);
                _wallTiles-&gt;addObject(tile);
            }
        }
</code></pre><p>一个<code>Block</code>由20个存储在<code>_wallTiles</code>中的<code>CCSprite</code>和5个存储在<code>_roofTiles</code>中的<code>CCSprite</code>组成。即一个Block对象，5个瓷砖宽，4个瓷砖高。I made the decision that no building in the game would exceed this size. If you decide to change this, then here is where you will make your changes.</p><p><code>initBlock</code>还将创建5个烟囱精灵，放在屋顶上。These will be spread out later according to the building type and could be very easily turned into obstacles for our <code>_player</code>. We also create the animation actions for the puffs of smoke, here inside <code>initBlock</code>.</p><p>Moving on to our new <code>setupBlock</code> method, this is where the unnecessary tiles and chimneys are turned invisible and where we spread out the visible chimneys. We begin the method as follows:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void Block::setupBlock (int width, int height, int type) {
        this-&amp;gt;setPuffing(false);
        _type = type;
        _width = width * _tileWidth;
        // add the roof height to the final height of the block
        _height = height * _tileHeight + _tileHeight * 0.49f;
        this-&amp;gt;setPositionY(_height);
        CCSpriteFrame * wallFrame;
        CCSpriteFrame * roofFrame = rand() % 10 &amp;gt; 6 ? _roof1 : _roof2;
        int num_chimneys;
        float chimneyX[] = {0,0,0,0,0};
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> Block::setupBlock (<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> type) {
        <span class="hljs-keyword">this</span>-&gt;setPuffing(<span class="hljs-keyword">false</span>);
        _type = type;
        _width = width * _tileWidth;
        <span class="hljs-comment">// add the roof height to the final height of the block</span>
        _height = height * _tileHeight + _tileHeight * <span class="hljs-number">0.49f</span>;
        <span class="hljs-keyword">this</span>-&gt;setPositionY(_height);
        CCSpriteFrame * wallFrame;
        CCSpriteFrame * roofFrame = rand() % <span class="hljs-number">10</span> &gt; <span class="hljs-number">6</span> ? _roof1 : _roof2;
        <span class="hljs-keyword">int</span> num_chimneys;
        <span class="hljs-keyword">float</span> chimneyX[] = {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>};
</code></pre><p>Then based on building type, we give different x positions for the chimney sprites and determine the texture we’ll use on the wall tiles.</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    switch (type) {
    case kBlockGap:
        this-&amp;gt;setVisible(false);
        return;
    case kBlock1:
        wallFrame = _tile1;
        chimneyX[0] = 0.2f;
        chimneyX[1] = 0.8f;
        num_chimneys = 2;
        break;
    case kBlock2:
        wallFrame = _tile2;
        chimneyX[0] = 0.2f;
        chimneyX[1] = 0.8f;
        chimneyX[2] = 0.5f;
        num_chimneys = 3;
        break;
    case kBlock3:
        wallFrame = _tile3;
        chimneyX[0] = 0.2f;
        chimneyX[1] = 0.8f;
        chimneyX[2] = 0.5f;
        num_chimneys = 3;
        break;
    case kBlock4:
        wallFrame = _tile4;
        chimneyX[0] = 0.2f;
        chimneyX[1] = 0.5f;
        num_chimneys = 2;
        break;
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">switch</span> (type) {
    <span class="hljs-keyword">case</span> kBlockGap:
        <span class="hljs-keyword">this</span>-&gt;setVisible(<span class="hljs-keyword">false</span>);
        <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">case</span> kBlock1:
        wallFrame = _tile1;
        chimneyX[<span class="hljs-number">0</span>] = <span class="hljs-number">0.2f</span>;
        chimneyX[<span class="hljs-number">1</span>] = <span class="hljs-number">0.8f</span>;
        num_chimneys = <span class="hljs-number">2</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> kBlock2:
        wallFrame = _tile2;
        chimneyX[<span class="hljs-number">0</span>] = <span class="hljs-number">0.2f</span>;
        chimneyX[<span class="hljs-number">1</span>] = <span class="hljs-number">0.8f</span>;
        chimneyX[<span class="hljs-number">2</span>] = <span class="hljs-number">0.5f</span>;
        num_chimneys = <span class="hljs-number">3</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> kBlock3:
        wallFrame = _tile3;
        chimneyX[<span class="hljs-number">0</span>] = <span class="hljs-number">0.2f</span>;
        chimneyX[<span class="hljs-number">1</span>] = <span class="hljs-number">0.8f</span>;
        chimneyX[<span class="hljs-number">2</span>] = <span class="hljs-number">0.5f</span>;
        num_chimneys = <span class="hljs-number">3</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> kBlock4:
        wallFrame = _tile4;
        chimneyX[<span class="hljs-number">0</span>] = <span class="hljs-number">0.2f</span>;
        chimneyX[<span class="hljs-number">1</span>] = <span class="hljs-number">0.5f</span>;
        num_chimneys = <span class="hljs-number">2</span>;
        <span class="hljs-keyword">break</span>;
    }
</code></pre><p>The method then proceeds to position the visible chimneys. We finally move to texturing the building. The logic to texture the roof and wall tiles is the same; for instance, here’s how the walls are tiled by changing the texture of each CCSprite wall through the <code>setDisplayFrame</code> method, and then turning unused tiles invisible:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;        count = _wallTiles-&amp;gt;count();
        for (i = 0; i &amp;lt; count; i++) {
            tile = (CCSprite *) _wallTiles-&amp;gt;objectAtIndex(i);
            if (tile-&amp;gt;getPositionX() &amp;lt; _width &amp;amp;&amp;amp; tile
                -&amp;gt;getPositionY() &amp;gt; -_height) {
                tile-&amp;gt;setVisible(true);
                tile-&amp;gt;setDisplayFrame(wallFrame);
            } else {
                tile-&amp;gt;setVisible(false);
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;">        count = _wallTiles-&gt;count();
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count; i++) {
            tile = (CCSprite *) _wallTiles-&gt;objectAtIndex(i);
            <span class="hljs-keyword">if</span> (tile-&gt;getPositionX() &lt; _width &amp;&amp; tile
                -&gt;getPositionY() &gt; -_height) {
                tile-&gt;setVisible(<span class="hljs-keyword">true</span>);
                tile-&gt;setDisplayFrame(wallFrame);
            } <span class="hljs-keyword">else</span> {
                tile-&gt;setVisible(<span class="hljs-keyword">false</span>);
            }
        }
    }
</code></pre><p>When we instantiate a <code>Block</code> in <code>initBlock</code>, we create a 5 x 4 building made out of wall tiles and roof tiles, each a CCSprite. And when we need to turn this building into a 3 x 2 building, or 4 x 4 building, or whatever, we simply turn the excess tiles invisible at the end of setupBlock.</p><h3 id="containers-within-containers"><a name="containers-within-containers" href="#containers-within-containers"></a>Containers within containers</h3><p>Before we move to the parallax effect logic, there is something I wanted to talk about related to the layering of our <code>_gameBatchNode</code>, which you’ll recall is a <code>CCSpriteBatchNode</code> object.</p><p>If you go to the static <code>create</code> method inside <code>Terrain.cpp</code>, you will notice that the object is still created with a reference to a <code>blank.png</code> texture:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;terrain-&amp;gt;initWithSpriteFrameName(&quot;blank.png&quot;)
&lt;/code&gt;&lt;/pre&gt;">terrain-&gt;initWithSpriteFrameName(<span class="hljs-string">"blank.png"</span>)
</code></pre><p>In fact the same 1x1 pixel image used in the test version is now in our sprite sheet, only this time the image is transparent. This is a bit of a hack, but necessary, <strong>因为如果一个精灵的纹理源与创建Batch node的源相同，则精灵只能被放入batch node</strong>。Now <code>Terrain</code> is just a container, it has no texture. But by setting its “blank” texture to something contained in our sprite sheet, we can place <code>_terrain</code> inside <code>_gameBatchNode</code>. The same thing is done with the <code>Block</code> class, which now, in the final version of the game, behaves as another textureless container. It will contain the various CCSprites for the wall and roof tiles as well as chimneys and puff animations as its children.</p><p>The organization of the layers inside our <code>_gameBatchNode</code> object can seem complex and at times even absurd. After all in the same node we have a foreground “layer” of lampposts, a middle-ground “layer” of buildings, and a background “layer” containing a cityscape. The player is also placed in the background but on top of the cityscape. And not only that but all three layers are moved at different speeds to create our parallax effect, and all this inside the same <code>CCSpriteBatchNode</code>! But the amount of code this arrangement saves us justifies any confusion we might have at times keeping the batch node organized. Now we can animate the puffs of smoke, for instance, and never worry about keeping them “attached” to their respective chimney sprite as the terrain scrolls to the left. <strong>The container will take care of keeping things together</strong>.</p><h3 id="创建视察滚动特效"><a name="创建视察滚动特效" href="#创建视察滚动特效"></a>创建视察滚动特效</h3><p>一个特殊的<code>CCNode</code>：<code>CCParallaxNode</code>。<code>CCParallaxNode</code> helps create parallax effect with finite layers, or finite scrolling, meaning you can use it if your game screen has a limit to how much it can scroll each way. Implementing <code>CCParallaxNode</code> to a game screen that can scroll indefinitely, such as the one in Victorian Rush Hour, usually requires more effort than it takes to build your own effect.</p><p>A parallax effect is created by moving objects at different depths by different speeds. The farther a layer appears from the screen, the slower its speed should be. In a game this usually means that the player sprite’s speed is fractioned and sent to all the layers that appear behind it, and multiplied for the layers that appear in front of the player sprite.</p><p>游戏中的时差滚动效果发生在主循环：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    // update parallax
    if (_player-&amp;gt;getVector().x &amp;gt; 0) {
        _background-&amp;gt;setPositionX(_background-&amp;gt;getPosition().x - _player-&amp;gt;getVector().x * 0.25f);
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-comment">// update parallax</span>
    <span class="hljs-keyword">if</span> (_player-&gt;getVector().x &gt; <span class="hljs-number">0</span>) {
        _background-&gt;setPositionX(_background-&gt;getPosition().x - _player-&gt;getVector().x * <span class="hljs-number">0.25f</span>);
</code></pre><p>先移动<code>_background</code>精灵，which contains the cityscape texture repeated three times along the x axis, 速度是<code>_player</code>的四分之一。</p><p>The <code>_background</code> scrolls to the left, and as soon as the first cityscape texture is off the screen, we shift the entire <code>_background</code> container to the right at precisely the spot where the second cityscape texture would appear if allowed to continue. We get this value by subtracting where the sprite would be from the total width of the sprite:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    float diffx;
    if (_background-&amp;gt;getPositionX() &amp;lt; -_background -&amp;gt;getContentSize().width) {
        diffx = fabs(_background-&amp;gt;getPositionX()) - _background-&amp;gt;getContentSize().width;
        _background-&amp;gt;setPositionX(-diffx);
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">float</span> diffx;
    <span class="hljs-keyword">if</span> (_background-&gt;getPositionX() &lt; -_background -&gt;getContentSize().width) {
        diffx = <span class="hljs-built_in">fabs</span>(_background-&gt;getPositionX()) - _background-&gt;getContentSize().width;
        _background-&gt;setPositionX(-diffx);
    }
</code></pre><p>So in effect we only ever scroll the first texture sprite inside the container.</p><p>A similar process is repeated with the <code>_foreground</code> sprite and the three lamppost sprites it contains, only the <code>_foreground</code> moves at four times the speed of the <code>_player</code> sprite:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    _foreground-&amp;gt;setPositionX(_foreground-&amp;gt;getPosition().x - _player-&amp;gt;getVector().x * 4);
    if (_foreground-&amp;gt;getPositionX() &amp;lt; -_foreground -&amp;gt;getContentSize().width * 4) {
        diffx = fabs(_foreground-&amp;gt;getPositionX())
            - _foreground -&amp;gt;getContentSize().width * 4;
        _foreground-&amp;gt;setPositionX(-diffx);
    }
&lt;/code&gt;&lt;/pre&gt;">    _foreground-&gt;setPositionX(_foreground-&gt;getPosition().x - _player-&gt;getVector().x * <span class="hljs-number">4</span>);
    <span class="hljs-keyword">if</span> (_foreground-&gt;getPositionX() &lt; -_foreground -&gt;getContentSize().width * <span class="hljs-number">4</span>) {
        diffx = <span class="hljs-built_in">fabs</span>(_foreground-&gt;getPositionX())
            - _foreground -&gt;getContentSize().width * <span class="hljs-number">4</span>;
        _foreground-&gt;setPositionX(-diffx);
    }
</code></pre><p>And we also employ our cloud sprites in the parallax effect. Since they appear behind the cityscape, so even farther away from the _player, the clouds move at an even lower rate (0.15):</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;        int count = _clouds-&amp;gt;count();
        CCSprite * cloud;
        for (int i = 0; i &amp;lt; count; i++) {
            cloud = (CCSprite *) _clouds-&amp;gt;objectAtIndex(i);
            cloud-&amp;gt;setPositionX(cloud-&amp;gt;getPositionX() - _player
                -&amp;gt;getVector().x * 0.15f);
            if (cloud-&amp;gt;getPositionX() + cloud
                -&amp;gt;boundingBox().size.width * 0.5f &amp;lt; 0 )
                cloud-&amp;gt;setPositionX(_screenSize.width + cloud
                    -&amp;gt;boundingBox().size.width * 0.5f);
        }
    }
&lt;/code&gt;&lt;/pre&gt;">        <span class="hljs-keyword">int</span> count = _clouds-&gt;count();
        CCSprite * cloud;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) {
            cloud = (CCSprite *) _clouds-&gt;objectAtIndex(i);
            cloud-&gt;setPositionX(cloud-&gt;getPositionX() - _player
                -&gt;getVector().x * <span class="hljs-number">0.15f</span>);
            <span class="hljs-keyword">if</span> (cloud-&gt;getPositionX() + cloud
                -&gt;boundingBox().size.width * <span class="hljs-number">0.5f</span> &lt; <span class="hljs-number">0</span> )
                cloud-&gt;setPositionX(_screenSize.width + cloud
                    -&gt;boundingBox().size.width * <span class="hljs-number">0.5f</span>);
        }
    }
</code></pre><h3 id="添加游戏菜单"><a name="添加游戏菜单" href="#添加游戏菜单"></a>添加游戏菜单</h3><p>使用一种特殊的层<code>CCLayer</code>——<code>CCMenu</code>。</p><p><code>CCMenu</code>是<code>CCMenuItemSprite</code>的集合。The layer is responsible for distributing its items as well as tracking touch events on all items.</p><p>In GameLayer.cpp, scroll down to the <code>createGameScreen</code> method. We’ll add the new logic to the end of this method. First, create the menu item for our start game button:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    CCSprite * menuItemOn;
    CCSprite * menuItemOff;
    menuItemOn = CCSprite::createWithSpriteFrameName(&quot;btn_new_on.png&quot;);
    menuItemOff = CCSprite::createWithSpriteFrameName(&quot;btn_new_off.png&quot;);
    CCMenuItemSprite * starGametItem = CCMenuItemSprite::create(
        menuItemOff,
        menuItemOn,
        this,
        menu_selector(GameLayer::startGame)
    );
&lt;/code&gt;&lt;/pre&gt;">    CCSprite * menuItemOn;
    CCSprite * menuItemOff;
    menuItemOn = CCSprite::createWithSpriteFrameName(<span class="hljs-string">"btn_new_on.png"</span>);
    menuItemOff = CCSprite::createWithSpriteFrameName(<span class="hljs-string">"btn_new_off.png"</span>);
    CCMenuItemSprite * starGametItem = CCMenuItemSprite::create(
        menuItemOff,
        menuItemOn,
        <span class="hljs-keyword">this</span>,
        menu_selector(GameLayer::startGame)
    );
</code></pre><p>Next we add the tutorial button:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    menuItemOn = CCSprite::createWithSpriteFrameName(&quot;btn_howto_on.png&quot;);
    menuItemOff = CCSprite::createWithSpriteFrameName(&quot;btn_howto_off.png&quot;);
    CCMenuItemSprite * howToItem = CCMenuItemSprite::create(
        menuItemOff,
        menuItemOn,
        this,
        menu_selector(GameLayer::showTutorial));
&lt;/code&gt;&lt;/pre&gt;">    menuItemOn = CCSprite::createWithSpriteFrameName(<span class="hljs-string">"btn_howto_on.png"</span>);
    menuItemOff = CCSprite::createWithSpriteFrameName(<span class="hljs-string">"btn_howto_off.png"</span>);
    CCMenuItemSprite * howToItem = CCMenuItemSprite::create(
        menuItemOff,
        menuItemOn,
        <span class="hljs-keyword">this</span>,
        menu_selector(GameLayer::showTutorial));
</code></pre><p>Then it’s time to create the menu:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    _mainMenu = CCMenu::create(howToItem, starGametItem, NULL);
    _mainMenu-&amp;gt;alignItemsHorizontallyWithPadding(120);
    _mainMenu-&amp;gt;setPosition(ccp(_screenSize.width * 0.5f, _screenSize.height * 0.54));
    this-&amp;gt;addChild(_mainMenu, kForeground);
&lt;/code&gt;&lt;/pre&gt;">    _mainMenu = CCMenu::create(howToItem, starGametItem, NULL);
    _mainMenu-&gt;alignItemsHorizontallyWithPadding(<span class="hljs-number">120</span>);
    _mainMenu-&gt;setPosition(ccp(_screenSize.width * <span class="hljs-number">0.5f</span>, _screenSize.height * <span class="hljs-number">0.54</span>));
    <span class="hljs-keyword">this</span>-&gt;addChild(_mainMenu, kForeground);
</code></pre><p>对齐方式：<code>alignItemsHorizontally</code>, <code>alignItemsHorizontallyWithPadding</code>, <code>alignItemsVertically</code>, <code>alignItemsVerticallyWithPadding</code>, <code>alignItemsInColumns</code>, <code>alignItemsInRows</code>。The items items appear in the order they are passed to the <code>CCMenu</code> constructor.</p><p>回调函数：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    void GameLayer::startGame (CCObject* pSender) {
        _tutorialLabel-&amp;gt;setVisible(false);
        _intro-&amp;gt;setVisible(false);
        _mainMenu-&amp;gt;setVisible(false);
        _jam-&amp;gt;runAction(_jamMove);
        SimpleAudioEngine::sharedEngine()-&amp;gt;playEffect(&quot;start.wav&quot;);
        _terrain-&amp;gt;setStartTerrain ( true );
        _state = kGamePlay;
    }
    void GameLayer::showTutorial (CCObject* pSender) {
        _tutorialLabel-&amp;gt;setString(&quot;Tap the screen to make the player jump.&quot;);
        _state = kGameTutorialJump;
        _jam-&amp;gt;runAction(_jamMove);
        _intro-&amp;gt;setVisible(false);
        _mainMenu-&amp;gt;setVisible(false);
        SimpleAudioEngine::sharedEngine()-&amp;gt;playEffect(&quot;start.wav&quot;);
        _tutorialLabel-&amp;gt;setVisible(true);
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">void</span> GameLayer::startGame (CCObject* pSender) {
        _tutorialLabel-&gt;setVisible(<span class="hljs-keyword">false</span>);
        _intro-&gt;setVisible(<span class="hljs-keyword">false</span>);
        _mainMenu-&gt;setVisible(<span class="hljs-keyword">false</span>);
        _jam-&gt;runAction(_jamMove);
        SimpleAudioEngine::sharedEngine()-&gt;playEffect(<span class="hljs-string">"start.wav"</span>);
        _terrain-&gt;setStartTerrain ( <span class="hljs-keyword">true</span> );
        _state = kGamePlay;
    }
    <span class="hljs-keyword">void</span> GameLayer::showTutorial (CCObject* pSender) {
        _tutorialLabel-&gt;setString(<span class="hljs-string">"Tap the screen to make the player jump."</span>);
        _state = kGameTutorialJump;
        _jam-&gt;runAction(_jamMove);
        _intro-&gt;setVisible(<span class="hljs-keyword">false</span>);
        _mainMenu-&gt;setVisible(<span class="hljs-keyword">false</span>);
        SimpleAudioEngine::sharedEngine()-&gt;playEffect(<span class="hljs-string">"start.wav"</span>);
        _tutorialLabel-&gt;setVisible(<span class="hljs-keyword">true</span>);
    }
</code></pre><h3 id="添加教程"><a name="添加教程" href="#添加教程"></a>添加教程</h3><p>The unspoken rule of game tutorials is: make it playable. And that’s what we’ll attempt to do here.</p><p>We’ll create a game state for our tutorial, and we’ll add a <code>CCLabelTTF</code> object to our stage, and make it invisible unless the tutorial state is on. We’ll use the <code>CCLabelTTF</code> to display our tutorial text.</p><p>Back to the <code>createGameScreen</code> method, add the following lines to create our <code>CCLabelTTF</code> object:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    _tutorialLabel = CCLabelTTF::create(&quot;&quot;, &quot;Times New Roman&quot;, 80);
    _tutorialLabel-&amp;gt;setPosition(ccp(_screenSize.width * 0.5f,
        _screenSize.height * 0.6f) );
    this-&amp;gt;addChild(_tutorialLabel, kForeground);
    _tutorialLabel-&amp;gt;setVisible(false);
&lt;/code&gt;&lt;/pre&gt;">    _tutorialLabel = CCLabelTTF::create(<span class="hljs-string">""</span>, <span class="hljs-string">"Times New Roman"</span>, <span class="hljs-number">80</span>);
    _tutorialLabel-&gt;setPosition(ccp(_screenSize.width * <span class="hljs-number">0.5f</span>,
        _screenSize.height * <span class="hljs-number">0.6f</span>) );
    <span class="hljs-keyword">this</span>-&gt;addChild(_tutorialLabel, kForeground);
    _tutorialLabel-&gt;setVisible(<span class="hljs-keyword">false</span>);
</code></pre><p>We add four states to our enumerated list of game states. These will represent the different steps in our tutorial:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    typedef enum {
        kGameIntro,
        kGamePlay,
        kGameOver,
        kGameTutorial,
        kGameTutorialJump,
        kGameTutorialFloat,
        kGameTutorialDrop
    } GameState;
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> {
        kGameIntro,
        kGamePlay,
        kGameOver,
        kGameTutorial,
        kGameTutorialJump,
        kGameTutorialFloat,
        kGameTutorialDrop
    } GameState;
</code></pre><p>The first tutorial state, <code>kGameTutorial</code>, acts as a separator from all other game states. So if the value for <code>_state</code> is greater than kGameTutorial, we are in tutorial mode.</p><p>Depending on the mode, we display a different message and we wait on a different condition to change to a new tutorial state.</p><p>If you recall, our <code>showTutorial</code> method starts with a message telling the player to tap the screen to make the sprite jump:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    _tutorialLabel-&amp;gt;setString(&quot;Tap the screen to make the player jump.&quot;);
    _state = kGameTutorialJump;
&lt;/code&gt;&lt;/pre&gt;">    _tutorialLabel-&gt;setString(<span class="hljs-string">"Tap the screen to make the player jump."</span>);
    _state = kGameTutorialJump;
</code></pre><p>Then in the <code>update</code> method, at the end of the method, we start adding the lines that will display the rest of our tutorial information. First if the player sprite is in the midst of a jump and has just begun falling:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    if (_state &amp;gt; kGameTutorial) {
        if (_state == kGameTutorialJump) {
            if (_player-&amp;gt;getState() == kPlayerFalling &amp;amp;&amp;amp; _player
                -&amp;gt;getVector().y &amp;lt; 0) {
                _player-&amp;gt;stopAllActions();
                _jam-&amp;gt;setVisible(false);
                _jam-&amp;gt;stopAllActions();
                _running = false;
                _tutorialLabel-&amp;gt;setString(&quot;While in the air, tap the screen to float.&quot;);
                _state = kGameTutorialFloat;
            }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">if</span> (_state &gt; kGameTutorial) {
        <span class="hljs-keyword">if</span> (_state == kGameTutorialJump) {
            <span class="hljs-keyword">if</span> (_player-&gt;getState() == kPlayerFalling &amp;&amp; _player
                -&gt;getVector().y &lt; <span class="hljs-number">0</span>) {
                _player-&gt;stopAllActions();
                _jam-&gt;setVisible(<span class="hljs-keyword">false</span>);
                _jam-&gt;stopAllActions();
                _running = <span class="hljs-keyword">false</span>;
                _tutorialLabel-&gt;setString(<span class="hljs-string">"While in the air, tap the screen to float."</span>);
                _state = kGameTutorialFloat;
            }
</code></pre><p>As you can see, we let the player know that another tap will open the umbrella and cause the sprite to float.</p><p>Next as the sprite is floating, when it reaches a certain distance from the buildings, we inform the player that another tap will close the umbrella and cause the sprite to drop:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;        } else if (_state == kGameTutorialFloat) {
            if (_player-&amp;gt;getPositionY() &amp;lt; _screenSize.height * 0.95f) {
                _player-&amp;gt;stopAllActions();
                _running = false;
                _tutorialLabel-&amp;gt;setString(&quot;While floating, tap the screen again to drop.&quot;);
                _state = kGameTutorialDrop;
            }

After that the tutorial is completed, and we show the message that the player may start the game:

```cpp
        } else {
            _tutorialLabel-&amp;gt;setString(&quot;That's it. Tap the screen to play.&quot;);
            _state = kGameTutorial;
        }
    }
&lt;/code&gt;&lt;/pre&gt;">        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_state == kGameTutorialFloat) {
            <span class="hljs-keyword">if</span> (_player-&gt;getPositionY() &lt; _screenSize.height * <span class="hljs-number">0.95f</span>) {
                _player-&gt;stopAllActions();
                _running = <span class="hljs-keyword">false</span>;
                _tutorialLabel-&gt;setString(<span class="hljs-string">"While floating, tap the screen again to drop."</span>);
                _state = kGameTutorialDrop;
            }

After that the tutorial is completed, and we show the message that the player may start the game:

```cpp
        } <span class="hljs-keyword">else</span> {
            _tutorialLabel-&gt;setString(<span class="hljs-string">"That's it. Tap the screen to play."</span>);
            _state = kGameTutorial;
        }
    }
</code></pre><p>Whenever we change a tutorial state, we pause the game momentarily and wait for a tap. We handle the rest of our logic inside <code>ccTouchesBegan</code>, so we’ll add that next.</p><p>Inside <code>ccTouchesBegan</code>, in the switch statement, add the following cases:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    case kGameTutorial:
        _tutorialLabel-&amp;gt;setString(&quot;&quot;);
        _tutorialLabel-&amp;gt;setVisible(false);
        _terrain-&amp;gt;setStartTerrain ( true );
        _state = kGamePlay;
        break;
    case kGameTutorialJump:
        if (_player-&amp;gt;getState() == kPlayerMoving) {
            SimpleAudioEngine::sharedEngine()
            -&amp;gt;playEffect(&quot;jump.wav&quot;);
            _player-&amp;gt;setJumping(true);
        }
        break;
    case kGameTutorialFloat:
        if (!_player-&amp;gt;getFloating()) {
            _player-&amp;gt;setFloating (true);
            _running = true;
        }
        break;
    case kGameTutorialDrop:
        _player-&amp;gt;setFloating (false);
        _running = true;
        break;
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">case</span> kGameTutorial:
        _tutorialLabel-&gt;setString(<span class="hljs-string">""</span>);
        _tutorialLabel-&gt;setVisible(<span class="hljs-keyword">false</span>);
        _terrain-&gt;setStartTerrain ( <span class="hljs-keyword">true</span> );
        _state = kGamePlay;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> kGameTutorialJump:
        <span class="hljs-keyword">if</span> (_player-&gt;getState() == kPlayerMoving) {
            SimpleAudioEngine::sharedEngine()
            -&gt;playEffect(<span class="hljs-string">"jump.wav"</span>);
            _player-&gt;setJumping(<span class="hljs-keyword">true</span>);
        }
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> kGameTutorialFloat:
        <span class="hljs-keyword">if</span> (!_player-&gt;getFloating()) {
            _player-&gt;setFloating (<span class="hljs-keyword">true</span>);
            _running = <span class="hljs-keyword">true</span>;
        }
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> kGameTutorialDrop:
        _player-&gt;setFloating (<span class="hljs-keyword">false</span>);
        _running = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">break</span>;
</code></pre><h2 id="8-box2d"><a name="8-box2d" href="#8-box2d"></a>8 Box2D</h2><p>Cocos2d-x comes bundled with templates for<br>projects utilizing either Box2D or Chipmunk. These are so-called 2D physics<br>engines; the first written in C++ and the second in C.</p><p>本书的例子将使用Box2D。The last two games I’ll show you will be developed with that engine, starting with a simple pool game to illustrate all the main points about using Box2D in your projects.</p><p>What you will learn:<br> How to create a project that incorporates Box2D<br> How to set up and run a Box2D simulation<br> How to create bodies<br> How to use the debug draw feature to quickly test your concepts<br> How to use collision filters and listeners</p><h3 id="创建box2d工程"><a name="创建box2d工程" href="#创建box2d工程"></a>创建Box2D工程</h3><p>Let’s start by going over the various steps involved in creating a Box2D project with Cocos2d-x. We begin by firing up Xcode and choosing File| New| Project. This time, we select the cocos2dx_box2dtemplate option.</p><p>If you run the project as-is in your iPhone simulator, you should see something like this:</p><p><img src="ch8-box2d-helloworld.png" alt=""></p><p>Please understand that the following steps are all optional. I happen not to like the way the Box2D project template is set up:</p><p>Go to the folder where you extracted the framework and locate the Testfiles, this time go to <code>samples/TestCpp/Classes/Box2DTestBed</code>. Drag the <code>GLES-Render.h</code> and <code>GLES-Render.cpp</code> files from <strong>Box2DTestBed</strong> to your project Classes group. Make sure to select <strong>Copy items into destination…</strong> and make sure you selected your project as the target.</p><p>In the <code>HelloWorldScene.h</code> header file, leave the includes in place, but change the class declarations to match this much shorter one:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    class HelloWorld : public cocos2d::CCLayer {
    public:
        ~HelloWorld();
        HelloWorld();
        static cocos2d::CCScene* scene();
        void initPhysics();
        virtual void draw();
        void update(float dt);
    private:
        b2World* world;
    };
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-keyword">class</span> HelloWorld : <span class="hljs-keyword">public</span> cocos2d::CCLayer {
    <span class="hljs-keyword">public</span>:
        ~HelloWorld();
        HelloWorld();
        <span class="hljs-keyword">static</span> cocos2d::CCScene* scene();
        <span class="hljs-keyword">void</span> initPhysics();
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> draw();
        <span class="hljs-keyword">void</span> update(<span class="hljs-keyword">float</span> dt);
    <span class="hljs-keyword">private</span>:
        b2World* world;
    };
</code></pre><p>Then add this include:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    #include &quot;GLES-Render.h&quot;
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> "GLES-Render.h"</span>
</code></pre><p>And add this private member:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    GLESDebugDraw * m_debugDraw;
&lt;/code&gt;&lt;/pre&gt;">    GLESDebugDraw * m_debugDraw;
</code></pre><p>Then in the <code>HelloWorldScene.cpp</code> implementation file replace the lines between <code>using namespace CocosDenshion</code> and the <code>HelloWorld::scene</code> method with these:</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    #define PTM_RATIO 32
    HelloWorld::HelloWorld()
    {
        this-&amp;gt;initPhysics();
        scheduleUpdate();
    }
    HelloWorld::~HelloWorld()
    {
        delete world;
        world = NULL;
        delete m_debugDraw;
    }
    void HelloWorld::initPhysics() {
        b2Vec2 gravity;
        gravity.Set(0.0f, -10.0f);
        world = new b2World(gravity);
        // Do we want to let bodies sleep?
        world-&amp;gt;SetAllowSleeping(true);
        world-&amp;gt;SetContinuousPhysics(true);
        m_debugDraw = new GLESDebugDraw( PTM_RATIO );
        world-&amp;gt;SetDebugDraw(m_debugDraw);
        uint32 flags = 0;
        flags += b2Draw::e_shapeBit;
            // flags += b2Draw::e_jointBit;
            // flags += b2Draw::e_aabbBit;
            // flags += b2Draw::e_pairBit;
            // flags += b2Draw::e_centerOfMassBit;
        m_debugDraw-&amp;gt;SetFlags(flags);
    }
    void HelloWorld::draw()
    {
        // IMPORTANT:
        // This is only for debug purposes
        // It is recommend to disable it
        CCLayer::draw();
        ccGLEnableVertexAttribs( kCCVertexAttribFlag_Position );
        kmGLPushMatrix();
        world-&amp;gt;DrawDebugData();
        kmGLPopMatrix();
    }
    void HelloWorld::update(float dt)
    {
        world-&amp;gt;Step(dt, 8, 1);
    }
&lt;/code&gt;&lt;/pre&gt;">    <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> PTM_RATIO 32</span>
    HelloWorld::HelloWorld()
    {
        <span class="hljs-keyword">this</span>-&gt;initPhysics();
        scheduleUpdate();
    }
    HelloWorld::~HelloWorld()
    {
        <span class="hljs-keyword">delete</span> world;
        world = NULL;
        <span class="hljs-keyword">delete</span> m_debugDraw;
    }
    <span class="hljs-keyword">void</span> HelloWorld::initPhysics() {
        b2Vec2 gravity;
        gravity.Set(<span class="hljs-number">0.0f</span>, -<span class="hljs-number">10.0f</span>);
        world = <span class="hljs-keyword">new</span> b2World(gravity);
        <span class="hljs-comment">// Do we want to let bodies sleep?</span>
        world-&gt;SetAllowSleeping(<span class="hljs-keyword">true</span>);
        world-&gt;SetContinuousPhysics(<span class="hljs-keyword">true</span>);
        m_debugDraw = <span class="hljs-keyword">new</span> GLESDebugDraw( PTM_RATIO );
        world-&gt;SetDebugDraw(m_debugDraw);
        uint32 flags = <span class="hljs-number">0</span>;
        flags += b2Draw::e_shapeBit;
            <span class="hljs-comment">// flags += b2Draw::e_jointBit;</span>
            <span class="hljs-comment">// flags += b2Draw::e_aabbBit;</span>
            <span class="hljs-comment">// flags += b2Draw::e_pairBit;</span>
            <span class="hljs-comment">// flags += b2Draw::e_centerOfMassBit;</span>
        m_debugDraw-&gt;SetFlags(flags);
    }
    <span class="hljs-keyword">void</span> HelloWorld::draw()
    {
        <span class="hljs-comment">// IMPORTANT:</span>
        <span class="hljs-comment">// This is only for debug purposes</span>
        <span class="hljs-comment">// It is recommend to disable it</span>
        CCLayer::draw();
        ccGLEnableVertexAttribs( kCCVertexAttribFlag_Position );
        kmGLPushMatrix();
        world-&gt;DrawDebugData();
        kmGLPopMatrix();
    }
    <span class="hljs-keyword">void</span> HelloWorld::update(<span class="hljs-keyword">float</span> dt)
    {
        world-&gt;Step(dt, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>);
    }
</code></pre><p>The GLES-Renderclass is necessary to use the debug draw feature in Box2D. This will draw all the elements from the simulation on the screen. The debug draw object is created inside the <code>initPhysics</code> method alongside the Box2D simulation (b2World). We’ll go over that logic in a moment.</p><p>As the comment inside the <code>draw</code> method states, the debug draw feature should be switched off once you’re done developing your game. So, all the lines pertaining to that object, as well as the <code>draw</code> method, should be commented out.</p><h3 id="什么是物理引擎"><a name="什么是物理引擎" href="#什么是物理引擎"></a>什么是物理引擎</h3><p>Box2D是一个非常鲁棒的碰撞检测引擎。可以仅作为碰撞检测引擎使用。But the simulation will also process and return a bunch of information derived from the collisions and the interactions between bodies, including how the objects should behave, based on their shapes, mass, and all the forces at play in the simulation.</p><h4 id="meet-box2d"><a name="meet-box2d" href="#meet-box2d"></a>Meet Box2D</h4><p>引擎的核心是<code>b2World</code>。This is the simulation. 向世界填充<code>b2Body</code>对象，and then you step through the simulation with <code>b2World-&gt;Step()</code>. You take the results of the simulation and display them to the user through your sprites, by grabbing a <code>b2Body</code>‘s position and rotation and applying them to a sprite.</p><p>The debug draw object allows you to see the simulation without using any sprites. A way to quickly test and prototype your game.</p><h4 id="meet-the-world"><a name="meet-the-world" href="#meet-the-world"></a>Meet the world</h4><p>多数情况下，物理引擎要求创建一个<code>b2world</code>对象。However, you can get interesting results by managing more than one world object in the same game, for multiple views for instance. But that’s for another book.</p><p>对于简单的工程，创建世界的方法如下：</p><pre><code class="cpp hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;cpp&quot;&gt;    b2Vec2 gravity;
    gravity.Set(0.0f, -10.0f);
    world = new b2World(gravity);
    // Do we want to let bodies sleep?
    world-&amp;gt;SetAllowSleeping(true);
    world-&amp;gt;SetContinuousPhysics(true);
    m_debugDraw = new GLESDebugDraw( PTM_RATIO );
    world-&amp;gt;SetDebugDraw(m_debugDraw);
    uint32 flags = 0;
    flags += b2Draw::e_shapeBit;
    // flags += b2Draw::e_jointBit;
    // flags += b2Draw::e_aabbBit;
    // flags += b2Draw::e_pairBit;
    // flags += b2Draw::e_centerOfMassBit;
    m_debugDraw-&amp;gt;SetFlags(flags);
&lt;/code&gt;&lt;/pre&gt;">    b2Vec2 gravity;
    gravity.Set(<span class="hljs-number">0.0f</span>, -<span class="hljs-number">10.0f</span>);
    world = <span class="hljs-keyword">new</span> b2World(gravity);
    <span class="hljs-comment">// Do we want to let bodies sleep?</span>
    world-&gt;SetAllowSleeping(<span class="hljs-keyword">true</span>);
    world-&gt;SetContinuousPhysics(<span class="hljs-keyword">true</span>);
    m_debugDraw = <span class="hljs-keyword">new</span> GLESDebugDraw( PTM_RATIO );
    world-&gt;SetDebugDraw(m_debugDraw);
    uint32 flags = <span class="hljs-number">0</span>;
    flags += b2Draw::e_shapeBit;
    <span class="hljs-comment">// flags += b2Draw::e_jointBit;</span>
    <span class="hljs-comment">// flags += b2Draw::e_aabbBit;</span>
    <span class="hljs-comment">// flags += b2Draw::e_pairBit;</span>
    <span class="hljs-comment">// flags += b2Draw::e_centerOfMassBit;</span>
    m_debugDraw-&gt;SetFlags(flags);
</code></pre><p>Box2D有自己的向量结构<code>b2Vec2</code>, and we use it here to create the world’s gravity. The <code>b2World</code> object receives that as its parameter. A simulation does not always require gravity of course; in that case the argument will be a (0, 0) vector.</p><p><code>SetAllowSleeping</code> means that if objects are not moving and are therefore not generating derived data, skip checking for derived data from those objects.</p><p><code>SetContinuousPhysics</code> means we have some fast objects in our hands, which we’ll later point out to the simulation, so it can pay extra attention for collisions. Then we create the debug draw object. This is optional, as I said before. The flags indicate what you wish to see in the drawing. In the previous code we only want to see the shapes of the objects.</p><p>Then comes <code>PTM_RATIO</code>, the defined constant that we passed as a parameter to the debug draw. Box2D uses meters instead of pixels for a variety of reasons that are, entirely unnecessary for anyone to know. But keep this one thing in mind: every pixel position value used in the game will be divided by this ratio constant (PTM stands for pixel to meter). If the result from this division ever gets above 10 or below 0.1, increase or decrease the value for PTM_RATIO accordingly.</p><p>Though you have some leeway, of course. By all means, play with this value once your game is completed, and pay special attention to the subtle differences in speed (another common value for this ratio is 100).</p>

<footer style="position:fixed; font-size:.8em; text-align:right; bottom:0px; margin-left:-25px; height:20px; width:100%;">generated by <a href="http://pad.haroopress.com" target="_blank">haroopad</a></footer>
</body>
</html>
